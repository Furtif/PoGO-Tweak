// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: POGOProtos.Networking.Envelopes.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "PogoprotosNetworkingEnvelopes.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PogoprotosNetworkingEnvelopesRoot

@implementation PogoprotosNetworkingEnvelopesRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PogoprotosNetworkingEnvelopesRoot_FileDescriptor

static GPBFileDescriptor *PogoprotosNetworkingEnvelopesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"POGOProtos.Networking.Envelopes"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AuthTicket

@implementation AuthTicket

@dynamic start;
@dynamic expireTimestampMs;
@dynamic end;

typedef struct AuthTicket__storage_ {
  uint32_t _has_storage_[1];
  NSData *start;
  NSData *end;
  uint64_t expireTimestampMs;
} AuthTicket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = AuthTicket_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthTicket__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expireTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = AuthTicket_FieldNumber_ExpireTimestampMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthTicket__storage_, expireTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = AuthTicket_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthTicket__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthTicket class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthTicket__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestEnvelope

@implementation RequestEnvelope

@dynamic statusCode;
@dynamic requestId;
@dynamic requestsArray, requestsArray_Count;
@dynamic platformRequestsArray, platformRequestsArray_Count;
@dynamic latitude;
@dynamic longitude;
@dynamic accuracy;
@dynamic hasAuthInfo, authInfo;
@dynamic hasAuthTicket, authTicket;
@dynamic msSinceLastLocationfix;

typedef struct RequestEnvelope__storage_ {
  uint32_t _has_storage_[1];
  int32_t statusCode;
  NSMutableArray *requestsArray;
  NSMutableArray *platformRequestsArray;
  RequestEnvelope_AuthInfo *authInfo;
  AuthTicket *authTicket;
  uint64_t requestId;
  double latitude;
  double longitude;
  double accuracy;
  int64_t msSinceLastLocationfix;
} RequestEnvelope__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, statusCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_FieldNumber_RequestId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, requestId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "requestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Request),
        .number = RequestEnvelope_FieldNumber_RequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, requestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "platformRequestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RequestEnvelope_PlatformRequest),
        .number = RequestEnvelope_FieldNumber_PlatformRequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, platformRequestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_FieldNumber_Latitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_FieldNumber_Longitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "accuracy",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_FieldNumber_Accuracy,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, accuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "authInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(RequestEnvelope_AuthInfo),
        .number = RequestEnvelope_FieldNumber_AuthInfo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, authInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = GPBStringifySymbol(AuthTicket),
        .number = RequestEnvelope_FieldNumber_AuthTicket,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, authTicket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msSinceLastLocationfix",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_FieldNumber_MsSinceLastLocationfix,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RequestEnvelope__storage_, msSinceLastLocationfix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestEnvelope class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestEnvelope__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestEnvelope_AuthInfo

@implementation RequestEnvelope_AuthInfo

@dynamic provider;
@dynamic hasToken, token;

typedef struct RequestEnvelope_AuthInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *provider;
  RequestEnvelope_AuthInfo_JWT *token;
} RequestEnvelope_AuthInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "provider",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_AuthInfo_FieldNumber_Provider,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestEnvelope_AuthInfo__storage_, provider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = GPBStringifySymbol(RequestEnvelope_AuthInfo_JWT),
        .number = RequestEnvelope_AuthInfo_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestEnvelope_AuthInfo__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestEnvelope_AuthInfo class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestEnvelope_AuthInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RequestEnvelope)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestEnvelope_AuthInfo_JWT

@implementation RequestEnvelope_AuthInfo_JWT

@dynamic contents;
@dynamic unknown2;

typedef struct RequestEnvelope_AuthInfo_JWT__storage_ {
  uint32_t _has_storage_[1];
  int32_t unknown2;
  NSString *contents;
} RequestEnvelope_AuthInfo_JWT__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contents",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_AuthInfo_JWT_FieldNumber_Contents,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestEnvelope_AuthInfo_JWT__storage_, contents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unknown2",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_AuthInfo_JWT_FieldNumber_Unknown2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestEnvelope_AuthInfo_JWT__storage_, unknown2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestEnvelope_AuthInfo_JWT class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestEnvelope_AuthInfo_JWT__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RequestEnvelope_AuthInfo)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestEnvelope_PlatformRequest

@implementation RequestEnvelope_PlatformRequest

@dynamic type;
@dynamic requestMessage;

typedef struct RequestEnvelope_PlatformRequest__storage_ {
  uint32_t _has_storage_[1];
  PlatformRequestType type;
  NSData *requestMessage;
} RequestEnvelope_PlatformRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PlatformRequestType_EnumDescriptor,
        .number = RequestEnvelope_PlatformRequest_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestEnvelope_PlatformRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "requestMessage",
        .dataTypeSpecific.className = NULL,
        .number = RequestEnvelope_PlatformRequest_FieldNumber_RequestMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestEnvelope_PlatformRequest__storage_, requestMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestEnvelope_PlatformRequest class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestEnvelope_PlatformRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RequestEnvelope)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RequestEnvelope_PlatformRequest_Type_RawValue(RequestEnvelope_PlatformRequest *message) {
  GPBDescriptor *descriptor = [RequestEnvelope_PlatformRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestEnvelope_PlatformRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRequestEnvelope_PlatformRequest_Type_RawValue(RequestEnvelope_PlatformRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RequestEnvelope_PlatformRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestEnvelope_PlatformRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ResponseEnvelope

@implementation ResponseEnvelope

@dynamic statusCode;
@dynamic requestId;
@dynamic apiURL;
@dynamic platformReturnsArray, platformReturnsArray_Count;
@dynamic hasAuthTicket, authTicket;
@dynamic returnsArray, returnsArray_Count;
@dynamic error;

typedef struct ResponseEnvelope__storage_ {
  uint32_t _has_storage_[1];
  ResponseEnvelope_StatusCode statusCode;
  NSString *apiURL;
  NSMutableArray *platformReturnsArray;
  AuthTicket *authTicket;
  NSMutableArray *returnsArray;
  NSString *error;
  uint64_t requestId;
} ResponseEnvelope__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.enumDescFunc = ResponseEnvelope_StatusCode_EnumDescriptor,
        .number = ResponseEnvelope_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseEnvelope__storage_, statusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = ResponseEnvelope_FieldNumber_RequestId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseEnvelope__storage_, requestId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "apiURL",
        .dataTypeSpecific.className = NULL,
        .number = ResponseEnvelope_FieldNumber_ApiURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseEnvelope__storage_, apiURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platformReturnsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseEnvelope_PlatformResponse),
        .number = ResponseEnvelope_FieldNumber_PlatformReturnsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseEnvelope__storage_, platformReturnsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = GPBStringifySymbol(AuthTicket),
        .number = ResponseEnvelope_FieldNumber_AuthTicket,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseEnvelope__storage_, authTicket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "returnsArray",
        .dataTypeSpecific.className = NULL,
        .number = ResponseEnvelope_FieldNumber_ReturnsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseEnvelope__storage_, returnsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = ResponseEnvelope_FieldNumber_Error,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResponseEnvelope__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseEnvelope class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseEnvelope__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\003\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResponseEnvelope_StatusCode_RawValue(ResponseEnvelope *message) {
  GPBDescriptor *descriptor = [ResponseEnvelope descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseEnvelope_FieldNumber_StatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetResponseEnvelope_StatusCode_RawValue(ResponseEnvelope *message, int32_t value) {
  GPBDescriptor *descriptor = [ResponseEnvelope descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseEnvelope_FieldNumber_StatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ResponseEnvelope_StatusCode

GPBEnumDescriptor *ResponseEnvelope_StatusCode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Ok\000OkRpcURLInResponse\000BadRequest"
        "\000InvalidRequest\000InvalidPlatformRequest\000R"
        "edirect\000SessionInvalidated\000InvalidAuthTo"
        "ken\000";
    static const int32_t values[] = {
        ResponseEnvelope_StatusCode_Unknown,
        ResponseEnvelope_StatusCode_Ok,
        ResponseEnvelope_StatusCode_OkRpcURLInResponse,
        ResponseEnvelope_StatusCode_BadRequest,
        ResponseEnvelope_StatusCode_InvalidRequest,
        ResponseEnvelope_StatusCode_InvalidPlatformRequest,
        ResponseEnvelope_StatusCode_Redirect,
        ResponseEnvelope_StatusCode_SessionInvalidated,
        ResponseEnvelope_StatusCode_InvalidAuthToken,
    };
    static const char *extraTextFormatInfo = "\001\002b\343\203\342\350\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseEnvelope_StatusCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseEnvelope_StatusCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseEnvelope_StatusCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseEnvelope_StatusCode_Unknown:
    case ResponseEnvelope_StatusCode_Ok:
    case ResponseEnvelope_StatusCode_OkRpcURLInResponse:
    case ResponseEnvelope_StatusCode_BadRequest:
    case ResponseEnvelope_StatusCode_InvalidRequest:
    case ResponseEnvelope_StatusCode_InvalidPlatformRequest:
    case ResponseEnvelope_StatusCode_Redirect:
    case ResponseEnvelope_StatusCode_SessionInvalidated:
    case ResponseEnvelope_StatusCode_InvalidAuthToken:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ResponseEnvelope_PlatformResponse

@implementation ResponseEnvelope_PlatformResponse

@dynamic type;
@dynamic response;

typedef struct ResponseEnvelope_PlatformResponse__storage_ {
  uint32_t _has_storage_[1];
  PlatformRequestType type;
  NSData *response;
} ResponseEnvelope_PlatformResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PlatformRequestType_EnumDescriptor,
        .number = ResponseEnvelope_PlatformResponse_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseEnvelope_PlatformResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "response",
        .dataTypeSpecific.className = NULL,
        .number = ResponseEnvelope_PlatformResponse_FieldNumber_Response,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseEnvelope_PlatformResponse__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseEnvelope_PlatformResponse class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseEnvelope_PlatformResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResponseEnvelope)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResponseEnvelope_PlatformResponse_Type_RawValue(ResponseEnvelope_PlatformResponse *message) {
  GPBDescriptor *descriptor = [ResponseEnvelope_PlatformResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseEnvelope_PlatformResponse_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetResponseEnvelope_PlatformResponse_Type_RawValue(ResponseEnvelope_PlatformResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ResponseEnvelope_PlatformResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseEnvelope_PlatformResponse_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Signature

@implementation Signature

@dynamic field1Array, field1Array_Count;
@dynamic timestampSinceStart;
@dynamic field3;
@dynamic locationFixArray, locationFixArray_Count;
@dynamic gpsInfoArray, gpsInfoArray_Count;
@dynamic field6Array, field6Array_Count;
@dynamic sensorInfoArray, sensorInfoArray_Count;
@dynamic hasDeviceInfo, deviceInfo;
@dynamic hasActivityStatus, activityStatus;
@dynamic locationHash1;
@dynamic field11;
@dynamic field12;
@dynamic field13;
@dynamic field14;
@dynamic field15;
@dynamic field16;
@dynamic field17;
@dynamic field18;
@dynamic field19;
@dynamic locationHash2;
@dynamic field21;
@dynamic sessionHash;
@dynamic timestamp;
@dynamic requestHashArray, requestHashArray_Count;
@dynamic unknown25;

typedef struct Signature__storage_ {
  uint32_t _has_storage_[1];
  int32_t locationHash1;
  int32_t field13;
  int32_t field14;
  int32_t field16;
  int32_t locationHash2;
  NSMutableArray *field1Array;
  NSString *field3;
  NSMutableArray *locationFixArray;
  NSMutableArray *gpsInfoArray;
  NSMutableArray *field6Array;
  NSMutableArray *sensorInfoArray;
  Signature_DeviceInfo *deviceInfo;
  Signature_ActivityStatus *activityStatus;
  NSString *field15;
  NSString *field17;
  NSString *field18;
  NSData *sessionHash;
  GPBUInt64Array *requestHashArray;
  uint64_t timestampSinceStart;
  uint64_t timestamp;
  int64_t unknown25;
} Signature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "field1Array",
        .dataTypeSpecific.className = GPBStringifySymbol(UnknownMessage),
        .number = Signature_FieldNumber_Field1Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature__storage_, field1Array),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampSinceStart",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_TimestampSinceStart,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature__storage_, timestampSinceStart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "field3",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field3,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature__storage_, field3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locationFixArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_LocationFix),
        .number = Signature_FieldNumber_LocationFixArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature__storage_, locationFixArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gpsInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_AndroidGpsInfo),
        .number = Signature_FieldNumber_GpsInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature__storage_, gpsInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "field6Array",
        .dataTypeSpecific.className = GPBStringifySymbol(UnknownMessage),
        .number = Signature_FieldNumber_Field6Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature__storage_, field6Array),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sensorInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_SensorInfo),
        .number = Signature_FieldNumber_SensorInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature__storage_, sensorInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_DeviceInfo),
        .number = Signature_FieldNumber_DeviceInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Signature__storage_, deviceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activityStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_ActivityStatus),
        .number = Signature_FieldNumber_ActivityStatus,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Signature__storage_, activityStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "locationHash1",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_LocationHash1,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Signature__storage_, locationHash1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "field11",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field11,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "field12",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field12,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "field13",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field13,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Signature__storage_, field13),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "field14",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field14,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Signature__storage_, field14),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "field15",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field15,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Signature__storage_, field15),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "field16",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field16,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Signature__storage_, field16),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "field17",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field17,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Signature__storage_, field17),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "field18",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field18,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Signature__storage_, field18),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "field19",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field19,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "locationHash2",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_LocationHash2,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Signature__storage_, locationHash2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "field21",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Field21,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sessionHash",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_SessionHash,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Signature__storage_, sessionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Timestamp,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(Signature__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "requestHashArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_RequestHashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature__storage_, requestHashArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unknown25",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Unknown25,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(Signature__storage_, unknown25),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_LocationFix

@implementation Signature_LocationFix

@dynamic provider;
@dynamic timestampSnapshot;
@dynamic altitude;
@dynamic latitude;
@dynamic longitude;
@dynamic speed;
@dynamic course;
@dynamic horizontalAccuracy;
@dynamic verticalAccuracy;
@dynamic providerStatus;
@dynamic floor;
@dynamic locationType;

typedef struct Signature_LocationFix__storage_ {
  uint32_t _has_storage_[1];
  float altitude;
  float latitude;
  float longitude;
  float speed;
  float course;
  float horizontalAccuracy;
  float verticalAccuracy;
  uint32_t floor;
  NSString *provider;
  uint64_t timestampSnapshot;
  uint64_t providerStatus;
  uint64_t locationType;
} Signature_LocationFix__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "provider",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Provider,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, provider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestampSnapshot",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_TimestampSnapshot,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, timestampSnapshot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "altitude",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Altitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, altitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Latitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Longitude,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Speed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "course",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Course,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, course),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "horizontalAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_HorizontalAccuracy,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, horizontalAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "verticalAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_VerticalAccuracy,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, verticalAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "providerStatus",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_ProviderStatus,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, providerStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "floor",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Floor,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, floor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "locationType",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_LocationType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, locationType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_LocationFix class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_LocationFix__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Signature)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_AndroidGpsInfo

@implementation Signature_AndroidGpsInfo

@dynamic timeToFix;
@dynamic satellitesPrnArray, satellitesPrnArray_Count;
@dynamic azimuthArray, azimuthArray_Count;
@dynamic elevationArray, elevationArray_Count;
@dynamic snrArray, snrArray_Count;
@dynamic hasAlmanacArray, hasAlmanacArray_Count;
@dynamic hasEphemerisArray, hasEphemerisArray_Count;
@dynamic usedInFixArray, usedInFixArray_Count;

typedef struct Signature_AndroidGpsInfo__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *satellitesPrnArray;
  GPBFloatArray *azimuthArray;
  GPBFloatArray *elevationArray;
  GPBFloatArray *snrArray;
  GPBBoolArray *hasAlmanacArray;
  GPBBoolArray *hasEphemerisArray;
  GPBBoolArray *usedInFixArray;
  uint64_t timeToFix;
} Signature_AndroidGpsInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeToFix",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_TimeToFix,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, timeToFix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "satellitesPrnArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_SatellitesPrnArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, satellitesPrnArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "azimuthArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_AzimuthArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, azimuthArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "elevationArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_ElevationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, elevationArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "snrArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_SnrArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, snrArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "hasAlmanacArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_HasAlmanacArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, hasAlmanacArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hasEphemerisArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_HasEphemerisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, hasEphemerisArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "usedInFixArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_UsedInFixArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, usedInFixArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_AndroidGpsInfo class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_AndroidGpsInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Signature)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_SensorInfo

@implementation Signature_SensorInfo

@dynamic timestampSnapshot;
@dynamic linearAccelerationX;
@dynamic linearAccelerationY;
@dynamic linearAccelerationZ;
@dynamic magneticFieldX;
@dynamic magneticFieldY;
@dynamic magneticFieldZ;
@dynamic magneticFieldAccuracy;
@dynamic attitudePitch;
@dynamic attitudeYaw;
@dynamic attitudeRoll;
@dynamic rotationRateX;
@dynamic rotationRateY;
@dynamic rotationRateZ;
@dynamic gravityX;
@dynamic gravityY;
@dynamic gravityZ;
@dynamic status;

typedef struct Signature_SensorInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t magneticFieldAccuracy;
  int32_t status;
  uint64_t timestampSnapshot;
  double linearAccelerationX;
  double linearAccelerationY;
  double linearAccelerationZ;
  double magneticFieldX;
  double magneticFieldY;
  double magneticFieldZ;
  double attitudePitch;
  double attitudeYaw;
  double attitudeRoll;
  double rotationRateX;
  double rotationRateY;
  double rotationRateZ;
  double gravityX;
  double gravityY;
  double gravityZ;
} Signature_SensorInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestampSnapshot",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_TimestampSnapshot,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, timestampSnapshot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "linearAccelerationX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_LinearAccelerationX,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, linearAccelerationX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "linearAccelerationY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_LinearAccelerationY,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, linearAccelerationY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "linearAccelerationZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_LinearAccelerationZ,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, linearAccelerationZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "magneticFieldX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_MagneticFieldX,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, magneticFieldX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "magneticFieldY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_MagneticFieldY,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, magneticFieldY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "magneticFieldZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_MagneticFieldZ,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, magneticFieldZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "magneticFieldAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_MagneticFieldAccuracy,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, magneticFieldAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attitudePitch",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_AttitudePitch,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, attitudePitch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "attitudeYaw",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_AttitudeYaw,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, attitudeYaw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "attitudeRoll",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_AttitudeRoll,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, attitudeRoll),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "rotationRateX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_RotationRateX,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, rotationRateX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "rotationRateY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_RotationRateY,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, rotationRateY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "rotationRateZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_RotationRateZ,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, rotationRateZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gravityX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GravityX,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gravityX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gravityY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GravityY,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gravityY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gravityZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GravityZ,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gravityZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_Status,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_SensorInfo class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_SensorInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Signature)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_DeviceInfo

@implementation Signature_DeviceInfo

@dynamic deviceId;
@dynamic androidBoardName;
@dynamic androidBootloader;
@dynamic deviceBrand;
@dynamic deviceModel;
@dynamic deviceModelIdentifier;
@dynamic deviceModelBoot;
@dynamic hardwareManufacturer;
@dynamic hardwareModel;
@dynamic firmwareBrand;
@dynamic firmwareTags;
@dynamic firmwareType;
@dynamic firmwareFingerprint;

typedef struct Signature_DeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceId;
  NSString *androidBoardName;
  NSString *androidBootloader;
  NSString *deviceBrand;
  NSString *deviceModel;
  NSString *deviceModelIdentifier;
  NSString *deviceModelBoot;
  NSString *hardwareManufacturer;
  NSString *hardwareModel;
  NSString *firmwareBrand;
  NSString *firmwareTags;
  NSString *firmwareType;
  NSString *firmwareFingerprint;
} Signature_DeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidBoardName",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_AndroidBoardName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, androidBoardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidBootloader",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_AndroidBootloader,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, androidBootloader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceBrand",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceBrand,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceBrand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceModel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModelIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceModelIdentifier,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceModelIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModelBoot",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceModelBoot,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceModelBoot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareManufacturer",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_HardwareManufacturer,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, hardwareManufacturer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareModel",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_HardwareModel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, hardwareModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareBrand",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_FirmwareBrand,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, firmwareBrand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareTags",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_FirmwareTags,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, firmwareTags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareType",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_FirmwareType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, firmwareType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareFingerprint",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_FirmwareFingerprint,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, firmwareFingerprint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_DeviceInfo class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_DeviceInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Signature)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_ActivityStatus

@implementation Signature_ActivityStatus

@dynamic startTimeMs;
@dynamic unknownStatus;
@dynamic walking;
@dynamic running;
@dynamic stationary;
@dynamic automotive;
@dynamic tilting;
@dynamic cycling;
@dynamic status;

typedef struct Signature_ActivityStatus__storage_ {
  uint32_t _has_storage_[1];
  NSData *status;
  uint64_t startTimeMs;
} Signature_ActivityStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTimeMs",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_StartTimeMs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_ActivityStatus__storage_, startTimeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unknownStatus",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_UnknownStatus,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "walking",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Walking,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "running",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Running,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "stationary",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Stationary,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "automotive",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Automotive,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "tilting",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Tilting,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cycling",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Cycling,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Status,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Signature_ActivityStatus__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_ActivityStatus class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_ActivityStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Signature)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnknownMessage

@implementation UnknownMessage


typedef struct UnknownMessage__storage_ {
  uint32_t _has_storage_[1];
} UnknownMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnknownMessage class]
                                     rootClass:[PogoprotosNetworkingEnvelopesRoot class]
                                          file:PogoprotosNetworkingEnvelopesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(UnknownMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
