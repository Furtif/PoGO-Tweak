// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: POGOProtos.Networking.Responses.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "PogoprotosNetworkingResponses.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PogoprotosNetworkingResponsesRoot

@implementation PogoprotosNetworkingResponsesRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PogoprotosNetworkingResponsesRoot_FileDescriptor

static GPBFileDescriptor *PogoprotosNetworkingResponsesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"POGOProtos.Networking.Responses"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AddFortModifierResponse

@implementation AddFortModifierResponse

@dynamic result;
@dynamic hasFortDetails, fortDetails;

typedef struct AddFortModifierResponse__storage_ {
  uint32_t _has_storage_[1];
  AddFortModifierResponse_Result result;
  FortDetailsResponse *fortDetails;
} AddFortModifierResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = AddFortModifierResponse_Result_EnumDescriptor,
        .number = AddFortModifierResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFortModifierResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fortDetails",
        .dataTypeSpecific.className = GPBStringifySymbol(FortDetailsResponse),
        .number = AddFortModifierResponse_FieldNumber_FortDetails,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFortModifierResponse__storage_, fortDetails),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFortModifierResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFortModifierResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AddFortModifierResponse_Result_RawValue(AddFortModifierResponse *message) {
  GPBDescriptor *descriptor = [AddFortModifierResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AddFortModifierResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetAddFortModifierResponse_Result_RawValue(AddFortModifierResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [AddFortModifierResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AddFortModifierResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum AddFortModifierResponse_Result

GPBEnumDescriptor *AddFortModifierResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoResultSet\000Success\000FortAlreadyHasModifi"
        "er\000TooFarAway\000NoItemInInventory\000PoiInacc"
        "essible\000";
    static const int32_t values[] = {
        AddFortModifierResponse_Result_NoResultSet,
        AddFortModifierResponse_Result_Success,
        AddFortModifierResponse_Result_FortAlreadyHasModifier,
        AddFortModifierResponse_Result_TooFarAway,
        AddFortModifierResponse_Result_NoItemInInventory,
        AddFortModifierResponse_Result_PoiInaccessible,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AddFortModifierResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AddFortModifierResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AddFortModifierResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case AddFortModifierResponse_Result_NoResultSet:
    case AddFortModifierResponse_Result_Success:
    case AddFortModifierResponse_Result_FortAlreadyHasModifier:
    case AddFortModifierResponse_Result_TooFarAway:
    case AddFortModifierResponse_Result_NoItemInInventory:
    case AddFortModifierResponse_Result_PoiInaccessible:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AttackGymResponse

@implementation AttackGymResponse

@dynamic result;
@dynamic hasBattleLog, battleLog;
@dynamic battleId;
@dynamic hasActiveDefender, activeDefender;
@dynamic hasActiveAttacker, activeAttacker;

typedef struct AttackGymResponse__storage_ {
  uint32_t _has_storage_[1];
  AttackGymResponse_Result result;
  BattleLog *battleLog;
  NSString *battleId;
  BattlePokemonInfo *activeDefender;
  BattlePokemonInfo *activeAttacker;
} AttackGymResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = AttackGymResponse_Result_EnumDescriptor,
        .number = AttackGymResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AttackGymResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "battleLog",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleLog),
        .number = AttackGymResponse_FieldNumber_BattleLog,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AttackGymResponse__storage_, battleLog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "battleId",
        .dataTypeSpecific.className = NULL,
        .number = AttackGymResponse_FieldNumber_BattleId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AttackGymResponse__storage_, battleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "activeDefender",
        .dataTypeSpecific.className = GPBStringifySymbol(BattlePokemonInfo),
        .number = AttackGymResponse_FieldNumber_ActiveDefender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AttackGymResponse__storage_, activeDefender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activeAttacker",
        .dataTypeSpecific.className = GPBStringifySymbol(BattlePokemonInfo),
        .number = AttackGymResponse_FieldNumber_ActiveAttacker,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AttackGymResponse__storage_, activeAttacker),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttackGymResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttackGymResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AttackGymResponse_Result_RawValue(AttackGymResponse *message) {
  GPBDescriptor *descriptor = [AttackGymResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AttackGymResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetAttackGymResponse_Result_RawValue(AttackGymResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [AttackGymResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AttackGymResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum AttackGymResponse_Result

GPBEnumDescriptor *AttackGymResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorInvalidAttackActions\000"
        "ErrorNotInRange\000";
    static const int32_t values[] = {
        AttackGymResponse_Result_Unset,
        AttackGymResponse_Result_Success,
        AttackGymResponse_Result_ErrorInvalidAttackActions,
        AttackGymResponse_Result_ErrorNotInRange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AttackGymResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AttackGymResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AttackGymResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case AttackGymResponse_Result_Unset:
    case AttackGymResponse_Result_Success:
    case AttackGymResponse_Result_ErrorInvalidAttackActions:
    case AttackGymResponse_Result_ErrorNotInRange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CatchPokemonResponse

@implementation CatchPokemonResponse

@dynamic status;
@dynamic missPercent;
@dynamic capturedPokemonId;
@dynamic hasCaptureAward, captureAward;
@dynamic captureReason;
@dynamic displayPokedexId;

typedef struct CatchPokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  CatchPokemonResponse_CatchStatus status;
  CatchPokemonResponse_CaptureReason captureReason;
  int32_t displayPokedexId;
  CaptureAward *captureAward;
  double missPercent;
  uint64_t capturedPokemonId;
} CatchPokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = CatchPokemonResponse_CatchStatus_EnumDescriptor,
        .number = CatchPokemonResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CatchPokemonResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "missPercent",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonResponse_FieldNumber_MissPercent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CatchPokemonResponse__storage_, missPercent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "capturedPokemonId",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonResponse_FieldNumber_CapturedPokemonId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CatchPokemonResponse__storage_, capturedPokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "captureAward",
        .dataTypeSpecific.className = GPBStringifySymbol(CaptureAward),
        .number = CatchPokemonResponse_FieldNumber_CaptureAward,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CatchPokemonResponse__storage_, captureAward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "captureReason",
        .dataTypeSpecific.enumDescFunc = CatchPokemonResponse_CaptureReason_EnumDescriptor,
        .number = CatchPokemonResponse_FieldNumber_CaptureReason,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CatchPokemonResponse__storage_, captureReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "displayPokedexId",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonResponse_FieldNumber_DisplayPokedexId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CatchPokemonResponse__storage_, displayPokedexId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CatchPokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CatchPokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CatchPokemonResponse_Status_RawValue(CatchPokemonResponse *message) {
  GPBDescriptor *descriptor = [CatchPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CatchPokemonResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetCatchPokemonResponse_Status_RawValue(CatchPokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [CatchPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CatchPokemonResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t CatchPokemonResponse_CaptureReason_RawValue(CatchPokemonResponse *message) {
  GPBDescriptor *descriptor = [CatchPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CatchPokemonResponse_FieldNumber_CaptureReason];
  return GPBGetMessageInt32Field(message, field);
}

void SetCatchPokemonResponse_CaptureReason_RawValue(CatchPokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [CatchPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CatchPokemonResponse_FieldNumber_CaptureReason];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum CatchPokemonResponse_CatchStatus

GPBEnumDescriptor *CatchPokemonResponse_CatchStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CatchError\000CatchSuccess\000CatchEscape\000Catc"
        "hFlee\000CatchMissed\000";
    static const int32_t values[] = {
        CatchPokemonResponse_CatchStatus_CatchError,
        CatchPokemonResponse_CatchStatus_CatchSuccess,
        CatchPokemonResponse_CatchStatus_CatchEscape,
        CatchPokemonResponse_CatchStatus_CatchFlee,
        CatchPokemonResponse_CatchStatus_CatchMissed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CatchPokemonResponse_CatchStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CatchPokemonResponse_CatchStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CatchPokemonResponse_CatchStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case CatchPokemonResponse_CatchStatus_CatchError:
    case CatchPokemonResponse_CatchStatus_CatchSuccess:
    case CatchPokemonResponse_CatchStatus_CatchEscape:
    case CatchPokemonResponse_CatchStatus_CatchFlee:
    case CatchPokemonResponse_CatchStatus_CatchMissed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CatchPokemonResponse_CaptureReason

GPBEnumDescriptor *CatchPokemonResponse_CaptureReason_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Default\000ElementalBadge\000CriticalCat"
        "ch\000";
    static const int32_t values[] = {
        CatchPokemonResponse_CaptureReason_Unset,
        CatchPokemonResponse_CaptureReason_Default,
        CatchPokemonResponse_CaptureReason_ElementalBadge,
        CatchPokemonResponse_CaptureReason_CriticalCatch,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CatchPokemonResponse_CaptureReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CatchPokemonResponse_CaptureReason_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CatchPokemonResponse_CaptureReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case CatchPokemonResponse_CaptureReason_Unset:
    case CatchPokemonResponse_CaptureReason_Default:
    case CatchPokemonResponse_CaptureReason_ElementalBadge:
    case CatchPokemonResponse_CaptureReason_CriticalCatch:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CheckAwardedBadgesResponse

@implementation CheckAwardedBadgesResponse

@dynamic success;
@dynamic awardedBadgesArray, awardedBadgesArray_Count;
@dynamic awardedBadgeLevelsArray, awardedBadgeLevelsArray_Count;
@dynamic avatarTemplateIdsArray, avatarTemplateIdsArray_Count;

typedef struct CheckAwardedBadgesResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *awardedBadgesArray;
  GPBInt32Array *awardedBadgeLevelsArray;
  NSMutableArray *avatarTemplateIdsArray;
} CheckAwardedBadgesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = CheckAwardedBadgesResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "awardedBadgesArray",
        .dataTypeSpecific.enumDescFunc = BadgeType_EnumDescriptor,
        .number = CheckAwardedBadgesResponse_FieldNumber_AwardedBadgesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckAwardedBadgesResponse__storage_, awardedBadgesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "awardedBadgeLevelsArray",
        .dataTypeSpecific.className = NULL,
        .number = CheckAwardedBadgesResponse_FieldNumber_AwardedBadgeLevelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckAwardedBadgesResponse__storage_, awardedBadgeLevelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "avatarTemplateIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = CheckAwardedBadgesResponse_FieldNumber_AvatarTemplateIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckAwardedBadgesResponse__storage_, avatarTemplateIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckAwardedBadgesResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckAwardedBadgesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckChallengeResponse

@implementation CheckChallengeResponse

@dynamic showChallenge;
@dynamic challengeURL;

typedef struct CheckChallengeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *challengeURL;
} CheckChallengeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "showChallenge",
        .dataTypeSpecific.className = NULL,
        .number = CheckChallengeResponse_FieldNumber_ShowChallenge,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "challengeURL",
        .dataTypeSpecific.className = NULL,
        .number = CheckChallengeResponse_FieldNumber_ChallengeURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckChallengeResponse__storage_, challengeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckChallengeResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckChallengeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckCodenameAvailableResponse

@implementation CheckCodenameAvailableResponse

@dynamic codename;
@dynamic userMessage;
@dynamic isAssignable;
@dynamic status;

typedef struct CheckCodenameAvailableResponse__storage_ {
  uint32_t _has_storage_[1];
  CheckCodenameAvailableResponse_Status status;
  NSString *codename;
  NSString *userMessage;
} CheckCodenameAvailableResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codename",
        .dataTypeSpecific.className = NULL,
        .number = CheckCodenameAvailableResponse_FieldNumber_Codename,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckCodenameAvailableResponse__storage_, codename),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userMessage",
        .dataTypeSpecific.className = NULL,
        .number = CheckCodenameAvailableResponse_FieldNumber_UserMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckCodenameAvailableResponse__storage_, userMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAssignable",
        .dataTypeSpecific.className = NULL,
        .number = CheckCodenameAvailableResponse_FieldNumber_IsAssignable,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = CheckCodenameAvailableResponse_Status_EnumDescriptor,
        .number = CheckCodenameAvailableResponse_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CheckCodenameAvailableResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckCodenameAvailableResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckCodenameAvailableResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CheckCodenameAvailableResponse_Status_RawValue(CheckCodenameAvailableResponse *message) {
  GPBDescriptor *descriptor = [CheckCodenameAvailableResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CheckCodenameAvailableResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetCheckCodenameAvailableResponse_Status_RawValue(CheckCodenameAvailableResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [CheckCodenameAvailableResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CheckCodenameAvailableResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum CheckCodenameAvailableResponse_Status

GPBEnumDescriptor *CheckCodenameAvailableResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000CodenameNotAvailable\000Coden"
        "ameNotValid\000CurrentOwner\000CodenameChangeN"
        "otAllowed\000";
    static const int32_t values[] = {
        CheckCodenameAvailableResponse_Status_Unset,
        CheckCodenameAvailableResponse_Status_Success,
        CheckCodenameAvailableResponse_Status_CodenameNotAvailable,
        CheckCodenameAvailableResponse_Status_CodenameNotValid,
        CheckCodenameAvailableResponse_Status_CurrentOwner,
        CheckCodenameAvailableResponse_Status_CodenameChangeNotAllowed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CheckCodenameAvailableResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CheckCodenameAvailableResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CheckCodenameAvailableResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case CheckCodenameAvailableResponse_Status_Unset:
    case CheckCodenameAvailableResponse_Status_Success:
    case CheckCodenameAvailableResponse_Status_CodenameNotAvailable:
    case CheckCodenameAvailableResponse_Status_CodenameNotValid:
    case CheckCodenameAvailableResponse_Status_CurrentOwner:
    case CheckCodenameAvailableResponse_Status_CodenameChangeNotAllowed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ClaimCodenameResponse

@implementation ClaimCodenameResponse

@dynamic codename;
@dynamic userMessage;
@dynamic isAssignable;
@dynamic status;
@dynamic hasUpdatedPlayer, updatedPlayer;

typedef struct ClaimCodenameResponse__storage_ {
  uint32_t _has_storage_[1];
  ClaimCodenameResponse_Status status;
  NSString *codename;
  NSString *userMessage;
  PlayerData *updatedPlayer;
} ClaimCodenameResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codename",
        .dataTypeSpecific.className = NULL,
        .number = ClaimCodenameResponse_FieldNumber_Codename,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClaimCodenameResponse__storage_, codename),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userMessage",
        .dataTypeSpecific.className = NULL,
        .number = ClaimCodenameResponse_FieldNumber_UserMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClaimCodenameResponse__storage_, userMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAssignable",
        .dataTypeSpecific.className = NULL,
        .number = ClaimCodenameResponse_FieldNumber_IsAssignable,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ClaimCodenameResponse_Status_EnumDescriptor,
        .number = ClaimCodenameResponse_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ClaimCodenameResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "updatedPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerData),
        .number = ClaimCodenameResponse_FieldNumber_UpdatedPlayer,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ClaimCodenameResponse__storage_, updatedPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClaimCodenameResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClaimCodenameResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ClaimCodenameResponse_Status_RawValue(ClaimCodenameResponse *message) {
  GPBDescriptor *descriptor = [ClaimCodenameResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClaimCodenameResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetClaimCodenameResponse_Status_RawValue(ClaimCodenameResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ClaimCodenameResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClaimCodenameResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ClaimCodenameResponse_Status

GPBEnumDescriptor *ClaimCodenameResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000CodenameNotAvailable\000Coden"
        "ameNotValid\000CurrentOwner\000CodenameChangeN"
        "otAllowed\000";
    static const int32_t values[] = {
        ClaimCodenameResponse_Status_Unset,
        ClaimCodenameResponse_Status_Success,
        ClaimCodenameResponse_Status_CodenameNotAvailable,
        ClaimCodenameResponse_Status_CodenameNotValid,
        ClaimCodenameResponse_Status_CurrentOwner,
        ClaimCodenameResponse_Status_CodenameChangeNotAllowed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClaimCodenameResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClaimCodenameResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClaimCodenameResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClaimCodenameResponse_Status_Unset:
    case ClaimCodenameResponse_Status_Success:
    case ClaimCodenameResponse_Status_CodenameNotAvailable:
    case ClaimCodenameResponse_Status_CodenameNotValid:
    case ClaimCodenameResponse_Status_CurrentOwner:
    case ClaimCodenameResponse_Status_CodenameChangeNotAllowed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CollectDailyBonusResponse

@implementation CollectDailyBonusResponse

@dynamic result;

typedef struct CollectDailyBonusResponse__storage_ {
  uint32_t _has_storage_[1];
  CollectDailyBonusResponse_Result result;
} CollectDailyBonusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = CollectDailyBonusResponse_Result_EnumDescriptor,
        .number = CollectDailyBonusResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CollectDailyBonusResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectDailyBonusResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectDailyBonusResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CollectDailyBonusResponse_Result_RawValue(CollectDailyBonusResponse *message) {
  GPBDescriptor *descriptor = [CollectDailyBonusResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CollectDailyBonusResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetCollectDailyBonusResponse_Result_RawValue(CollectDailyBonusResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [CollectDailyBonusResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CollectDailyBonusResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum CollectDailyBonusResponse_Result

GPBEnumDescriptor *CollectDailyBonusResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Failure\000TooSoon\000";
    static const int32_t values[] = {
        CollectDailyBonusResponse_Result_Unset,
        CollectDailyBonusResponse_Result_Success,
        CollectDailyBonusResponse_Result_Failure,
        CollectDailyBonusResponse_Result_TooSoon,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CollectDailyBonusResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CollectDailyBonusResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CollectDailyBonusResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case CollectDailyBonusResponse_Result_Unset:
    case CollectDailyBonusResponse_Result_Success:
    case CollectDailyBonusResponse_Result_Failure:
    case CollectDailyBonusResponse_Result_TooSoon:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CollectDailyDefenderBonusResponse

@implementation CollectDailyDefenderBonusResponse

@dynamic result;
@dynamic currencyTypeArray, currencyTypeArray_Count;
@dynamic currencyAwardedArray, currencyAwardedArray_Count;
@dynamic defendersCount;

typedef struct CollectDailyDefenderBonusResponse__storage_ {
  uint32_t _has_storage_[1];
  CollectDailyDefenderBonusResponse_Result result;
  int32_t defendersCount;
  NSMutableArray *currencyTypeArray;
  GPBInt32Array *currencyAwardedArray;
} CollectDailyDefenderBonusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = CollectDailyDefenderBonusResponse_Result_EnumDescriptor,
        .number = CollectDailyDefenderBonusResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CollectDailyDefenderBonusResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "currencyTypeArray",
        .dataTypeSpecific.className = NULL,
        .number = CollectDailyDefenderBonusResponse_FieldNumber_CurrencyTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CollectDailyDefenderBonusResponse__storage_, currencyTypeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currencyAwardedArray",
        .dataTypeSpecific.className = NULL,
        .number = CollectDailyDefenderBonusResponse_FieldNumber_CurrencyAwardedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CollectDailyDefenderBonusResponse__storage_, currencyAwardedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "defendersCount",
        .dataTypeSpecific.className = NULL,
        .number = CollectDailyDefenderBonusResponse_FieldNumber_DefendersCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CollectDailyDefenderBonusResponse__storage_, defendersCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectDailyDefenderBonusResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectDailyDefenderBonusResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CollectDailyDefenderBonusResponse_Result_RawValue(CollectDailyDefenderBonusResponse *message) {
  GPBDescriptor *descriptor = [CollectDailyDefenderBonusResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CollectDailyDefenderBonusResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetCollectDailyDefenderBonusResponse_Result_RawValue(CollectDailyDefenderBonusResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [CollectDailyDefenderBonusResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CollectDailyDefenderBonusResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum CollectDailyDefenderBonusResponse_Result

GPBEnumDescriptor *CollectDailyDefenderBonusResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Failure\000TooSoon\000NoDefender"
        "s\000";
    static const int32_t values[] = {
        CollectDailyDefenderBonusResponse_Result_Unset,
        CollectDailyDefenderBonusResponse_Result_Success,
        CollectDailyDefenderBonusResponse_Result_Failure,
        CollectDailyDefenderBonusResponse_Result_TooSoon,
        CollectDailyDefenderBonusResponse_Result_NoDefenders,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CollectDailyDefenderBonusResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CollectDailyDefenderBonusResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CollectDailyDefenderBonusResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case CollectDailyDefenderBonusResponse_Result_Unset:
    case CollectDailyDefenderBonusResponse_Result_Success:
    case CollectDailyDefenderBonusResponse_Result_Failure:
    case CollectDailyDefenderBonusResponse_Result_TooSoon:
    case CollectDailyDefenderBonusResponse_Result_NoDefenders:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DiskEncounterResponse

@implementation DiskEncounterResponse

@dynamic result;
@dynamic hasPokemonData, pokemonData;
@dynamic hasCaptureProbability, captureProbability;
@dynamic activeItem;

typedef struct DiskEncounterResponse__storage_ {
  uint32_t _has_storage_[1];
  DiskEncounterResponse_Result result;
  ItemId activeItem;
  PokemonData *pokemonData;
  CaptureProbability *captureProbability;
} DiskEncounterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = DiskEncounterResponse_Result_EnumDescriptor,
        .number = DiskEncounterResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DiskEncounterResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonData",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = DiskEncounterResponse_FieldNumber_PokemonData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DiskEncounterResponse__storage_, pokemonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "captureProbability",
        .dataTypeSpecific.className = GPBStringifySymbol(CaptureProbability),
        .number = DiskEncounterResponse_FieldNumber_CaptureProbability,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DiskEncounterResponse__storage_, captureProbability),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activeItem",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = DiskEncounterResponse_FieldNumber_ActiveItem,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DiskEncounterResponse__storage_, activeItem),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DiskEncounterResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DiskEncounterResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DiskEncounterResponse_Result_RawValue(DiskEncounterResponse *message) {
  GPBDescriptor *descriptor = [DiskEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DiskEncounterResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetDiskEncounterResponse_Result_RawValue(DiskEncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [DiskEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DiskEncounterResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t DiskEncounterResponse_ActiveItem_RawValue(DiskEncounterResponse *message) {
  GPBDescriptor *descriptor = [DiskEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DiskEncounterResponse_FieldNumber_ActiveItem];
  return GPBGetMessageInt32Field(message, field);
}

void SetDiskEncounterResponse_ActiveItem_RawValue(DiskEncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [DiskEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DiskEncounterResponse_FieldNumber_ActiveItem];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum DiskEncounterResponse_Result

GPBEnumDescriptor *DiskEncounterResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Success\000NotAvailable\000NotInRange\000"
        "EncounterAlreadyFinished\000PokemonInventor"
        "yFull\000";
    static const int32_t values[] = {
        DiskEncounterResponse_Result_Unknown,
        DiskEncounterResponse_Result_Success,
        DiskEncounterResponse_Result_NotAvailable,
        DiskEncounterResponse_Result_NotInRange,
        DiskEncounterResponse_Result_EncounterAlreadyFinished,
        DiskEncounterResponse_Result_PokemonInventoryFull,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DiskEncounterResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DiskEncounterResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DiskEncounterResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case DiskEncounterResponse_Result_Unknown:
    case DiskEncounterResponse_Result_Success:
    case DiskEncounterResponse_Result_NotAvailable:
    case DiskEncounterResponse_Result_NotInRange:
    case DiskEncounterResponse_Result_EncounterAlreadyFinished:
    case DiskEncounterResponse_Result_PokemonInventoryFull:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DownloadItemTemplatesResponse

@implementation DownloadItemTemplatesResponse

@dynamic result;
@dynamic itemTemplatesArray, itemTemplatesArray_Count;
@dynamic timestampMs;
@dynamic pageOffset;

typedef struct DownloadItemTemplatesResponse__storage_ {
  uint32_t _has_storage_[1];
  DownloadItemTemplatesResponse_Result result;
  int32_t pageOffset;
  NSMutableArray *itemTemplatesArray;
  uint64_t timestampMs;
} DownloadItemTemplatesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = DownloadItemTemplatesResponse_Result_EnumDescriptor,
        .number = DownloadItemTemplatesResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "itemTemplatesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DownloadItemTemplatesResponse_ItemTemplate),
        .number = DownloadItemTemplatesResponse_FieldNumber_ItemTemplatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse__storage_, itemTemplatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampMs",
        .dataTypeSpecific.className = NULL,
        .number = DownloadItemTemplatesResponse_FieldNumber_TimestampMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse__storage_, timestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pageOffset",
        .dataTypeSpecific.className = NULL,
        .number = DownloadItemTemplatesResponse_FieldNumber_PageOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse__storage_, pageOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadItemTemplatesResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadItemTemplatesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DownloadItemTemplatesResponse_Result_RawValue(DownloadItemTemplatesResponse *message) {
  GPBDescriptor *descriptor = [DownloadItemTemplatesResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownloadItemTemplatesResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetDownloadItemTemplatesResponse_Result_RawValue(DownloadItemTemplatesResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [DownloadItemTemplatesResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownloadItemTemplatesResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum DownloadItemTemplatesResponse_Result

GPBEnumDescriptor *DownloadItemTemplatesResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Page\000Retry\000";
    static const int32_t values[] = {
        DownloadItemTemplatesResponse_Result_Unset,
        DownloadItemTemplatesResponse_Result_Success,
        DownloadItemTemplatesResponse_Result_Page,
        DownloadItemTemplatesResponse_Result_Retry,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DownloadItemTemplatesResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DownloadItemTemplatesResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DownloadItemTemplatesResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case DownloadItemTemplatesResponse_Result_Unset:
    case DownloadItemTemplatesResponse_Result_Success:
    case DownloadItemTemplatesResponse_Result_Page:
    case DownloadItemTemplatesResponse_Result_Retry:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DownloadItemTemplatesResponse_ItemTemplate

@implementation DownloadItemTemplatesResponse_ItemTemplate

@dynamic templateId;
@dynamic hasPokemonSettings, pokemonSettings;
@dynamic hasItemSettings, itemSettings;
@dynamic hasMoveSettings, moveSettings;
@dynamic hasMoveSequenceSettings, moveSequenceSettings;
@dynamic hasTypeEffective, typeEffective;
@dynamic hasBadgeSettings, badgeSettings;
@dynamic hasCamera, camera;
@dynamic hasPlayerLevel, playerLevel;
@dynamic hasGymLevel, gymLevel;
@dynamic hasBattleSettings, battleSettings;
@dynamic hasEncounterSettings, encounterSettings;
@dynamic hasIapItemDisplay, iapItemDisplay;
@dynamic hasIapSettings, iapSettings;
@dynamic hasPokemonUpgrades, pokemonUpgrades;
@dynamic hasEquippedBadges, equippedBadges;
@dynamic hasQuestSettings, questSettings;
@dynamic hasAvatarCustomization, avatarCustomization;
@dynamic hasFormSettings, formSettings;
@dynamic hasGenderSettings, genderSettings;

typedef struct DownloadItemTemplatesResponse_ItemTemplate__storage_ {
  uint32_t _has_storage_[1];
  NSString *templateId;
  PokemonSettings *pokemonSettings;
  ItemSettings *itemSettings;
  MoveSettings *moveSettings;
  MoveSequenceSettings *moveSequenceSettings;
  TypeEffectiveSettings *typeEffective;
  BadgeSettings *badgeSettings;
  CameraSettings *camera;
  PlayerLevelSettings *playerLevel;
  GymLevelSettings *gymLevel;
  GymBattleSettings *battleSettings;
  EncounterSettings *encounterSettings;
  IapItemDisplay *iapItemDisplay;
  IapSettings *iapSettings;
  PokemonUpgradeSettings *pokemonUpgrades;
  EquippedBadgeSettings *equippedBadges;
  QuestSettings *questSettings;
  AvatarCustomizationSettings *avatarCustomization;
  FormSettings *formSettings;
  GenderSettings *genderSettings;
} DownloadItemTemplatesResponse_ItemTemplate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "templateId",
        .dataTypeSpecific.className = NULL,
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_TemplateId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, templateId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pokemonSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_PokemonSettings,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, pokemonSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "itemSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(ItemSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_ItemSettings,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, itemSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "moveSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(MoveSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_MoveSettings,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, moveSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "moveSequenceSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(MoveSequenceSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_MoveSequenceSettings,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, moveSequenceSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "typeEffective",
        .dataTypeSpecific.className = GPBStringifySymbol(TypeEffectiveSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_TypeEffective,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, typeEffective),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "badgeSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(BadgeSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_BadgeSettings,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, badgeSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "camera",
        .dataTypeSpecific.className = GPBStringifySymbol(CameraSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_Camera,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, camera),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerLevel",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerLevelSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_PlayerLevel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, playerLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gymLevel",
        .dataTypeSpecific.className = GPBStringifySymbol(GymLevelSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_GymLevel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, gymLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "battleSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(GymBattleSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_BattleSettings,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, battleSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "encounterSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(EncounterSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_EncounterSettings,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, encounterSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "iapItemDisplay",
        .dataTypeSpecific.className = GPBStringifySymbol(IapItemDisplay),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_IapItemDisplay,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, iapItemDisplay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "iapSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(IapSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_IapSettings,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, iapSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pokemonUpgrades",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonUpgradeSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_PokemonUpgrades,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, pokemonUpgrades),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "equippedBadges",
        .dataTypeSpecific.className = GPBStringifySymbol(EquippedBadgeSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_EquippedBadges,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, equippedBadges),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "questSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(QuestSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_QuestSettings,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, questSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "avatarCustomization",
        .dataTypeSpecific.className = GPBStringifySymbol(AvatarCustomizationSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_AvatarCustomization,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, avatarCustomization),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "formSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(FormSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_FormSettings,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, formSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "genderSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(GenderSettings),
        .number = DownloadItemTemplatesResponse_ItemTemplate_FieldNumber_GenderSettings,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesResponse_ItemTemplate__storage_, genderSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadItemTemplatesResponse_ItemTemplate class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadItemTemplatesResponse_ItemTemplate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DownloadItemTemplatesResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownloadRemoteConfigVersionResponse

@implementation DownloadRemoteConfigVersionResponse

@dynamic result;
@dynamic itemTemplatesTimestampMs;
@dynamic assetDigestTimestampMs;

typedef struct DownloadRemoteConfigVersionResponse__storage_ {
  uint32_t _has_storage_[1];
  DownloadRemoteConfigVersionResponse_Result result;
  uint64_t itemTemplatesTimestampMs;
  uint64_t assetDigestTimestampMs;
} DownloadRemoteConfigVersionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = DownloadRemoteConfigVersionResponse_Result_EnumDescriptor,
        .number = DownloadRemoteConfigVersionResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownloadRemoteConfigVersionResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "itemTemplatesTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = DownloadRemoteConfigVersionResponse_FieldNumber_ItemTemplatesTimestampMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DownloadRemoteConfigVersionResponse__storage_, itemTemplatesTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "assetDigestTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = DownloadRemoteConfigVersionResponse_FieldNumber_AssetDigestTimestampMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownloadRemoteConfigVersionResponse__storage_, assetDigestTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadRemoteConfigVersionResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadRemoteConfigVersionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DownloadRemoteConfigVersionResponse_Result_RawValue(DownloadRemoteConfigVersionResponse *message) {
  GPBDescriptor *descriptor = [DownloadRemoteConfigVersionResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownloadRemoteConfigVersionResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetDownloadRemoteConfigVersionResponse_Result_RawValue(DownloadRemoteConfigVersionResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [DownloadRemoteConfigVersionResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownloadRemoteConfigVersionResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum DownloadRemoteConfigVersionResponse_Result

GPBEnumDescriptor *DownloadRemoteConfigVersionResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000";
    static const int32_t values[] = {
        DownloadRemoteConfigVersionResponse_Result_Unset,
        DownloadRemoteConfigVersionResponse_Result_Success,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DownloadRemoteConfigVersionResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DownloadRemoteConfigVersionResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DownloadRemoteConfigVersionResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case DownloadRemoteConfigVersionResponse_Result_Unset:
    case DownloadRemoteConfigVersionResponse_Result_Success:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DownloadSettingsResponse

@implementation DownloadSettingsResponse

@dynamic error;
@dynamic hash_p;
@dynamic hasSettings, settings;

typedef struct DownloadSettingsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *error;
  NSString *hash_p;
  GlobalSettings *settings;
} DownloadSettingsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = DownloadSettingsResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownloadSettingsResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = DownloadSettingsResponse_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DownloadSettingsResponse__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "settings",
        .dataTypeSpecific.className = GPBStringifySymbol(GlobalSettings),
        .number = DownloadSettingsResponse_FieldNumber_Settings,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownloadSettingsResponse__storage_, settings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadSettingsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadSettingsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EchoResponse

@implementation EchoResponse

@dynamic context;

typedef struct EchoResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *context;
} EchoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = NULL,
        .number = EchoResponse_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EchoResponse__storage_, context),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EchoResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EchoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncounterResponse

@implementation EncounterResponse

@dynamic hasWildPokemon, wildPokemon;
@dynamic background;
@dynamic status;
@dynamic hasCaptureProbability, captureProbability;
@dynamic activeItem;

typedef struct EncounterResponse__storage_ {
  uint32_t _has_storage_[1];
  EncounterResponse_Background background;
  EncounterResponse_Status status;
  ItemId activeItem;
  WildPokemon *wildPokemon;
  CaptureProbability *captureProbability;
} EncounterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wildPokemon",
        .dataTypeSpecific.className = GPBStringifySymbol(WildPokemon),
        .number = EncounterResponse_FieldNumber_WildPokemon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncounterResponse__storage_, wildPokemon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "background",
        .dataTypeSpecific.enumDescFunc = EncounterResponse_Background_EnumDescriptor,
        .number = EncounterResponse_FieldNumber_Background,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncounterResponse__storage_, background),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = EncounterResponse_Status_EnumDescriptor,
        .number = EncounterResponse_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EncounterResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "captureProbability",
        .dataTypeSpecific.className = GPBStringifySymbol(CaptureProbability),
        .number = EncounterResponse_FieldNumber_CaptureProbability,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EncounterResponse__storage_, captureProbability),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activeItem",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = EncounterResponse_FieldNumber_ActiveItem,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EncounterResponse__storage_, activeItem),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncounterResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncounterResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EncounterResponse_Background_RawValue(EncounterResponse *message) {
  GPBDescriptor *descriptor = [EncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterResponse_FieldNumber_Background];
  return GPBGetMessageInt32Field(message, field);
}

void SetEncounterResponse_Background_RawValue(EncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [EncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterResponse_FieldNumber_Background];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t EncounterResponse_Status_RawValue(EncounterResponse *message) {
  GPBDescriptor *descriptor = [EncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetEncounterResponse_Status_RawValue(EncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [EncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t EncounterResponse_ActiveItem_RawValue(EncounterResponse *message) {
  GPBDescriptor *descriptor = [EncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterResponse_FieldNumber_ActiveItem];
  return GPBGetMessageInt32Field(message, field);
}

void SetEncounterResponse_ActiveItem_RawValue(EncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [EncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterResponse_FieldNumber_ActiveItem];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum EncounterResponse_Background

GPBEnumDescriptor *EncounterResponse_Background_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Park\000Desert\000";
    static const int32_t values[] = {
        EncounterResponse_Background_Park,
        EncounterResponse_Background_Desert,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EncounterResponse_Background)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EncounterResponse_Background_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EncounterResponse_Background_IsValidValue(int32_t value__) {
  switch (value__) {
    case EncounterResponse_Background_Park:
    case EncounterResponse_Background_Desert:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EncounterResponse_Status

GPBEnumDescriptor *EncounterResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "EncounterError\000EncounterSuccess\000Encounte"
        "rNotFound\000EncounterClosed\000EncounterPokem"
        "onFled\000EncounterNotInRange\000EncounterAlre"
        "adyHappened\000PokemonInventoryFull\000";
    static const int32_t values[] = {
        EncounterResponse_Status_EncounterError,
        EncounterResponse_Status_EncounterSuccess,
        EncounterResponse_Status_EncounterNotFound,
        EncounterResponse_Status_EncounterClosed,
        EncounterResponse_Status_EncounterPokemonFled,
        EncounterResponse_Status_EncounterNotInRange,
        EncounterResponse_Status_EncounterAlreadyHappened,
        EncounterResponse_Status_PokemonInventoryFull,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EncounterResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EncounterResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EncounterResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case EncounterResponse_Status_EncounterError:
    case EncounterResponse_Status_EncounterSuccess:
    case EncounterResponse_Status_EncounterNotFound:
    case EncounterResponse_Status_EncounterClosed:
    case EncounterResponse_Status_EncounterPokemonFled:
    case EncounterResponse_Status_EncounterNotInRange:
    case EncounterResponse_Status_EncounterAlreadyHappened:
    case EncounterResponse_Status_PokemonInventoryFull:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - EncounterTutorialCompleteResponse

@implementation EncounterTutorialCompleteResponse

@dynamic result;
@dynamic hasPokemonData, pokemonData;
@dynamic hasCaptureAward, captureAward;

typedef struct EncounterTutorialCompleteResponse__storage_ {
  uint32_t _has_storage_[1];
  EncounterTutorialCompleteResponse_Result result;
  PokemonData *pokemonData;
  CaptureAward *captureAward;
} EncounterTutorialCompleteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = EncounterTutorialCompleteResponse_Result_EnumDescriptor,
        .number = EncounterTutorialCompleteResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncounterTutorialCompleteResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonData",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = EncounterTutorialCompleteResponse_FieldNumber_PokemonData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncounterTutorialCompleteResponse__storage_, pokemonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "captureAward",
        .dataTypeSpecific.className = GPBStringifySymbol(CaptureAward),
        .number = EncounterTutorialCompleteResponse_FieldNumber_CaptureAward,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EncounterTutorialCompleteResponse__storage_, captureAward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncounterTutorialCompleteResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncounterTutorialCompleteResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EncounterTutorialCompleteResponse_Result_RawValue(EncounterTutorialCompleteResponse *message) {
  GPBDescriptor *descriptor = [EncounterTutorialCompleteResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterTutorialCompleteResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetEncounterTutorialCompleteResponse_Result_RawValue(EncounterTutorialCompleteResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [EncounterTutorialCompleteResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterTutorialCompleteResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum EncounterTutorialCompleteResponse_Result

GPBEnumDescriptor *EncounterTutorialCompleteResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorInvalidPokemon\000";
    static const int32_t values[] = {
        EncounterTutorialCompleteResponse_Result_Unset,
        EncounterTutorialCompleteResponse_Result_Success,
        EncounterTutorialCompleteResponse_Result_ErrorInvalidPokemon,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EncounterTutorialCompleteResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EncounterTutorialCompleteResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EncounterTutorialCompleteResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case EncounterTutorialCompleteResponse_Result_Unset:
    case EncounterTutorialCompleteResponse_Result_Success:
    case EncounterTutorialCompleteResponse_Result_ErrorInvalidPokemon:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - EquipBadgeResponse

@implementation EquipBadgeResponse

@dynamic result;
@dynamic hasEquipped, equipped;

typedef struct EquipBadgeResponse__storage_ {
  uint32_t _has_storage_[1];
  EquipBadgeResponse_Result result;
  EquippedBadge *equipped;
} EquipBadgeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = EquipBadgeResponse_Result_EnumDescriptor,
        .number = EquipBadgeResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EquipBadgeResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "equipped",
        .dataTypeSpecific.className = GPBStringifySymbol(EquippedBadge),
        .number = EquipBadgeResponse_FieldNumber_Equipped,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EquipBadgeResponse__storage_, equipped),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EquipBadgeResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EquipBadgeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EquipBadgeResponse_Result_RawValue(EquipBadgeResponse *message) {
  GPBDescriptor *descriptor = [EquipBadgeResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EquipBadgeResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetEquipBadgeResponse_Result_RawValue(EquipBadgeResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [EquipBadgeResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EquipBadgeResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum EquipBadgeResponse_Result

GPBEnumDescriptor *EquipBadgeResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000CooldownActive\000NotQualifie"
        "d\000";
    static const int32_t values[] = {
        EquipBadgeResponse_Result_Unset,
        EquipBadgeResponse_Result_Success,
        EquipBadgeResponse_Result_CooldownActive,
        EquipBadgeResponse_Result_NotQualified,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EquipBadgeResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EquipBadgeResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EquipBadgeResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case EquipBadgeResponse_Result_Unset:
    case EquipBadgeResponse_Result_Success:
    case EquipBadgeResponse_Result_CooldownActive:
    case EquipBadgeResponse_Result_NotQualified:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - EvolvePokemonResponse

@implementation EvolvePokemonResponse

@dynamic result;
@dynamic hasEvolvedPokemonData, evolvedPokemonData;
@dynamic experienceAwarded;
@dynamic candyAwarded;

typedef struct EvolvePokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  EvolvePokemonResponse_Result result;
  int32_t experienceAwarded;
  int32_t candyAwarded;
  PokemonData *evolvedPokemonData;
} EvolvePokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = EvolvePokemonResponse_Result_EnumDescriptor,
        .number = EvolvePokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EvolvePokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "evolvedPokemonData",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = EvolvePokemonResponse_FieldNumber_EvolvedPokemonData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EvolvePokemonResponse__storage_, evolvedPokemonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "experienceAwarded",
        .dataTypeSpecific.className = NULL,
        .number = EvolvePokemonResponse_FieldNumber_ExperienceAwarded,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EvolvePokemonResponse__storage_, experienceAwarded),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "candyAwarded",
        .dataTypeSpecific.className = NULL,
        .number = EvolvePokemonResponse_FieldNumber_CandyAwarded,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EvolvePokemonResponse__storage_, candyAwarded),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EvolvePokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EvolvePokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EvolvePokemonResponse_Result_RawValue(EvolvePokemonResponse *message) {
  GPBDescriptor *descriptor = [EvolvePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EvolvePokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetEvolvePokemonResponse_Result_RawValue(EvolvePokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [EvolvePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EvolvePokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum EvolvePokemonResponse_Result

GPBEnumDescriptor *EvolvePokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000FailedPokemonMissing\000Faile"
        "dInsufficientResources\000FailedPokemonCann"
        "otEvolve\000FailedPokemonIsDeployed\000FailedI"
        "nvalidItemRequirement\000";
    static const int32_t values[] = {
        EvolvePokemonResponse_Result_Unset,
        EvolvePokemonResponse_Result_Success,
        EvolvePokemonResponse_Result_FailedPokemonMissing,
        EvolvePokemonResponse_Result_FailedInsufficientResources,
        EvolvePokemonResponse_Result_FailedPokemonCannotEvolve,
        EvolvePokemonResponse_Result_FailedPokemonIsDeployed,
        EvolvePokemonResponse_Result_FailedInvalidItemRequirement,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EvolvePokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EvolvePokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EvolvePokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case EvolvePokemonResponse_Result_Unset:
    case EvolvePokemonResponse_Result_Success:
    case EvolvePokemonResponse_Result_FailedPokemonMissing:
    case EvolvePokemonResponse_Result_FailedInsufficientResources:
    case EvolvePokemonResponse_Result_FailedPokemonCannotEvolve:
    case EvolvePokemonResponse_Result_FailedPokemonIsDeployed:
    case EvolvePokemonResponse_Result_FailedInvalidItemRequirement:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FortDeployPokemonResponse

@implementation FortDeployPokemonResponse

@dynamic result;
@dynamic hasFortDetails, fortDetails;
@dynamic hasPokemonData, pokemonData;
@dynamic hasGymState, gymState;

typedef struct FortDeployPokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  FortDeployPokemonResponse_Result result;
  FortDetailsResponse *fortDetails;
  PokemonData *pokemonData;
  GymState *gymState;
} FortDeployPokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = FortDeployPokemonResponse_Result_EnumDescriptor,
        .number = FortDeployPokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FortDeployPokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fortDetails",
        .dataTypeSpecific.className = GPBStringifySymbol(FortDetailsResponse),
        .number = FortDeployPokemonResponse_FieldNumber_FortDetails,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FortDeployPokemonResponse__storage_, fortDetails),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pokemonData",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = FortDeployPokemonResponse_FieldNumber_PokemonData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FortDeployPokemonResponse__storage_, pokemonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gymState",
        .dataTypeSpecific.className = GPBStringifySymbol(GymState),
        .number = FortDeployPokemonResponse_FieldNumber_GymState,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FortDeployPokemonResponse__storage_, gymState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FortDeployPokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FortDeployPokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FortDeployPokemonResponse_Result_RawValue(FortDeployPokemonResponse *message) {
  GPBDescriptor *descriptor = [FortDeployPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortDeployPokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetFortDeployPokemonResponse_Result_RawValue(FortDeployPokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [FortDeployPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortDeployPokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum FortDeployPokemonResponse_Result

GPBEnumDescriptor *FortDeployPokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoResultSet\000Success\000ErrorAlreadyHasPokem"
        "onOnFort\000ErrorOpposingTeamOwnsFort\000Error"
        "FortIsFull\000ErrorNotInRange\000ErrorPlayerHa"
        "sNoTeam\000ErrorPokemonNotFullHp\000ErrorPlaye"
        "rBelowMinimumLevel\000ErrorPokemonIsBuddy\000E"
        "rrorFortDeployLockout\000ErrorPlayerHasNoNi"
        "ckname\000ErrorPoiInaccessible\000";
    static const int32_t values[] = {
        FortDeployPokemonResponse_Result_NoResultSet,
        FortDeployPokemonResponse_Result_Success,
        FortDeployPokemonResponse_Result_ErrorAlreadyHasPokemonOnFort,
        FortDeployPokemonResponse_Result_ErrorOpposingTeamOwnsFort,
        FortDeployPokemonResponse_Result_ErrorFortIsFull,
        FortDeployPokemonResponse_Result_ErrorNotInRange,
        FortDeployPokemonResponse_Result_ErrorPlayerHasNoTeam,
        FortDeployPokemonResponse_Result_ErrorPokemonNotFullHp,
        FortDeployPokemonResponse_Result_ErrorPlayerBelowMinimumLevel,
        FortDeployPokemonResponse_Result_ErrorPokemonIsBuddy,
        FortDeployPokemonResponse_Result_ErrorFortDeployLockout,
        FortDeployPokemonResponse_Result_ErrorPlayerHasNoNickname,
        FortDeployPokemonResponse_Result_ErrorPoiInaccessible,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FortDeployPokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FortDeployPokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FortDeployPokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case FortDeployPokemonResponse_Result_NoResultSet:
    case FortDeployPokemonResponse_Result_Success:
    case FortDeployPokemonResponse_Result_ErrorAlreadyHasPokemonOnFort:
    case FortDeployPokemonResponse_Result_ErrorOpposingTeamOwnsFort:
    case FortDeployPokemonResponse_Result_ErrorFortIsFull:
    case FortDeployPokemonResponse_Result_ErrorNotInRange:
    case FortDeployPokemonResponse_Result_ErrorPlayerHasNoTeam:
    case FortDeployPokemonResponse_Result_ErrorPokemonNotFullHp:
    case FortDeployPokemonResponse_Result_ErrorPlayerBelowMinimumLevel:
    case FortDeployPokemonResponse_Result_ErrorPokemonIsBuddy:
    case FortDeployPokemonResponse_Result_ErrorFortDeployLockout:
    case FortDeployPokemonResponse_Result_ErrorPlayerHasNoNickname:
    case FortDeployPokemonResponse_Result_ErrorPoiInaccessible:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FortDetailsResponse

@implementation FortDetailsResponse

@dynamic fortId;
@dynamic teamColor;
@dynamic hasPokemonData, pokemonData;
@dynamic name;
@dynamic imageUrlsArray, imageUrlsArray_Count;
@dynamic fp;
@dynamic stamina;
@dynamic maxStamina;
@dynamic type;
@dynamic latitude;
@dynamic longitude;
@dynamic description_p;
@dynamic modifiersArray, modifiersArray_Count;

typedef struct FortDetailsResponse__storage_ {
  uint32_t _has_storage_[1];
  TeamColor teamColor;
  int32_t fp;
  int32_t stamina;
  int32_t maxStamina;
  FortType type;
  NSString *fortId;
  PokemonData *pokemonData;
  NSString *name;
  NSMutableArray *imageUrlsArray;
  NSString *description_p;
  NSMutableArray *modifiersArray;
  double latitude;
  double longitude;
} FortDetailsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_FortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "teamColor",
        .dataTypeSpecific.enumDescFunc = TeamColor_EnumDescriptor,
        .number = FortDetailsResponse_FieldNumber_TeamColor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, teamColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonData",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = FortDetailsResponse_FieldNumber_PokemonData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, pokemonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageUrlsArray",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_ImageUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, imageUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fp",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_Fp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, fp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stamina",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_Stamina,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, stamina),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxStamina",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_MaxStamina,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, maxStamina),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = FortType_EnumDescriptor,
        .number = FortDetailsResponse_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_Latitude,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_Longitude,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsResponse_FieldNumber_Description_p,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modifiersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FortModifier),
        .number = FortDetailsResponse_FieldNumber_ModifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FortDetailsResponse__storage_, modifiersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FortDetailsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FortDetailsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FortDetailsResponse_TeamColor_RawValue(FortDetailsResponse *message) {
  GPBDescriptor *descriptor = [FortDetailsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortDetailsResponse_FieldNumber_TeamColor];
  return GPBGetMessageInt32Field(message, field);
}

void SetFortDetailsResponse_TeamColor_RawValue(FortDetailsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [FortDetailsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortDetailsResponse_FieldNumber_TeamColor];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FortDetailsResponse_Type_RawValue(FortDetailsResponse *message) {
  GPBDescriptor *descriptor = [FortDetailsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortDetailsResponse_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetFortDetailsResponse_Type_RawValue(FortDetailsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [FortDetailsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortDetailsResponse_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - FortRecallPokemonResponse

@implementation FortRecallPokemonResponse

@dynamic result;
@dynamic hasFortDetails, fortDetails;

typedef struct FortRecallPokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  FortRecallPokemonResponse_Result result;
  FortDetailsResponse *fortDetails;
} FortRecallPokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = FortRecallPokemonResponse_Result_EnumDescriptor,
        .number = FortRecallPokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FortRecallPokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fortDetails",
        .dataTypeSpecific.className = GPBStringifySymbol(FortDetailsResponse),
        .number = FortRecallPokemonResponse_FieldNumber_FortDetails,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FortRecallPokemonResponse__storage_, fortDetails),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FortRecallPokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FortRecallPokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FortRecallPokemonResponse_Result_RawValue(FortRecallPokemonResponse *message) {
  GPBDescriptor *descriptor = [FortRecallPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortRecallPokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetFortRecallPokemonResponse_Result_RawValue(FortRecallPokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [FortRecallPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortRecallPokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum FortRecallPokemonResponse_Result

GPBEnumDescriptor *FortRecallPokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoResultSet\000Success\000ErrorNotInRange\000Erro"
        "rPokemonNotOnFort\000ErrorNoPlayer\000";
    static const int32_t values[] = {
        FortRecallPokemonResponse_Result_NoResultSet,
        FortRecallPokemonResponse_Result_Success,
        FortRecallPokemonResponse_Result_ErrorNotInRange,
        FortRecallPokemonResponse_Result_ErrorPokemonNotOnFort,
        FortRecallPokemonResponse_Result_ErrorNoPlayer,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FortRecallPokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FortRecallPokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FortRecallPokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case FortRecallPokemonResponse_Result_NoResultSet:
    case FortRecallPokemonResponse_Result_Success:
    case FortRecallPokemonResponse_Result_ErrorNotInRange:
    case FortRecallPokemonResponse_Result_ErrorPokemonNotOnFort:
    case FortRecallPokemonResponse_Result_ErrorNoPlayer:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FortSearchResponse

@implementation FortSearchResponse

@dynamic result;
@dynamic itemsAwardedArray, itemsAwardedArray_Count;
@dynamic gemsAwarded;
@dynamic hasPokemonDataEgg, pokemonDataEgg;
@dynamic experienceAwarded;
@dynamic cooldownCompleteTimestampMs;
@dynamic chainHackSequenceNumber;

typedef struct FortSearchResponse__storage_ {
  uint32_t _has_storage_[1];
  FortSearchResponse_Result result;
  int32_t gemsAwarded;
  int32_t experienceAwarded;
  int32_t chainHackSequenceNumber;
  NSMutableArray *itemsAwardedArray;
  PokemonData *pokemonDataEgg;
  int64_t cooldownCompleteTimestampMs;
} FortSearchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = FortSearchResponse_Result_EnumDescriptor,
        .number = FortSearchResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FortSearchResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "itemsAwardedArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ItemAward),
        .number = FortSearchResponse_FieldNumber_ItemsAwardedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FortSearchResponse__storage_, itemsAwardedArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gemsAwarded",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchResponse_FieldNumber_GemsAwarded,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FortSearchResponse__storage_, gemsAwarded),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pokemonDataEgg",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = FortSearchResponse_FieldNumber_PokemonDataEgg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FortSearchResponse__storage_, pokemonDataEgg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "experienceAwarded",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchResponse_FieldNumber_ExperienceAwarded,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FortSearchResponse__storage_, experienceAwarded),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cooldownCompleteTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchResponse_FieldNumber_CooldownCompleteTimestampMs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FortSearchResponse__storage_, cooldownCompleteTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chainHackSequenceNumber",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchResponse_FieldNumber_ChainHackSequenceNumber,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FortSearchResponse__storage_, chainHackSequenceNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FortSearchResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FortSearchResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FortSearchResponse_Result_RawValue(FortSearchResponse *message) {
  GPBDescriptor *descriptor = [FortSearchResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortSearchResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetFortSearchResponse_Result_RawValue(FortSearchResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [FortSearchResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FortSearchResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum FortSearchResponse_Result

GPBEnumDescriptor *FortSearchResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoResultSet\000Success\000OutOfRange\000InCooldow"
        "nPeriod\000InventoryFull\000ExceededDailyLimit"
        "\000PoiInaccessible\000";
    static const int32_t values[] = {
        FortSearchResponse_Result_NoResultSet,
        FortSearchResponse_Result_Success,
        FortSearchResponse_Result_OutOfRange,
        FortSearchResponse_Result_InCooldownPeriod,
        FortSearchResponse_Result_InventoryFull,
        FortSearchResponse_Result_ExceededDailyLimit,
        FortSearchResponse_Result_PoiInaccessible,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FortSearchResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FortSearchResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FortSearchResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case FortSearchResponse_Result_NoResultSet:
    case FortSearchResponse_Result_Success:
    case FortSearchResponse_Result_OutOfRange:
    case FortSearchResponse_Result_InCooldownPeriod:
    case FortSearchResponse_Result_InventoryFull:
    case FortSearchResponse_Result_ExceededDailyLimit:
    case FortSearchResponse_Result_PoiInaccessible:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetAssetDigestResponse

@implementation GetAssetDigestResponse

@dynamic digestArray, digestArray_Count;
@dynamic timestampMs;
@dynamic result;
@dynamic pageOffset;

typedef struct GetAssetDigestResponse__storage_ {
  uint32_t _has_storage_[1];
  GetAssetDigestResponse_Result result;
  int32_t pageOffset;
  NSMutableArray *digestArray;
  uint64_t timestampMs;
} GetAssetDigestResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "digestArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AssetDigestEntry),
        .number = GetAssetDigestResponse_FieldNumber_DigestArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetAssetDigestResponse__storage_, digestArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampMs",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestResponse_FieldNumber_TimestampMs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAssetDigestResponse__storage_, timestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = GetAssetDigestResponse_Result_EnumDescriptor,
        .number = GetAssetDigestResponse_FieldNumber_Result,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAssetDigestResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pageOffset",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestResponse_FieldNumber_PageOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetAssetDigestResponse__storage_, pageOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAssetDigestResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAssetDigestResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetAssetDigestResponse_Result_RawValue(GetAssetDigestResponse *message) {
  GPBDescriptor *descriptor = [GetAssetDigestResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetAssetDigestResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetAssetDigestResponse_Result_RawValue(GetAssetDigestResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetAssetDigestResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetAssetDigestResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetAssetDigestResponse_Result

GPBEnumDescriptor *GetAssetDigestResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Page\000Retry\000";
    static const int32_t values[] = {
        GetAssetDigestResponse_Result_Unset,
        GetAssetDigestResponse_Result_Success,
        GetAssetDigestResponse_Result_Page,
        GetAssetDigestResponse_Result_Retry,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetAssetDigestResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetAssetDigestResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetAssetDigestResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetAssetDigestResponse_Result_Unset:
    case GetAssetDigestResponse_Result_Success:
    case GetAssetDigestResponse_Result_Page:
    case GetAssetDigestResponse_Result_Retry:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetBuddyWalkedResponse

@implementation GetBuddyWalkedResponse

@dynamic success;
@dynamic familyCandyId;
@dynamic candyEarnedCount;

typedef struct GetBuddyWalkedResponse__storage_ {
  uint32_t _has_storage_[1];
  PokemonFamilyId familyCandyId;
  int32_t candyEarnedCount;
} GetBuddyWalkedResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = GetBuddyWalkedResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "familyCandyId",
        .dataTypeSpecific.enumDescFunc = PokemonFamilyId_EnumDescriptor,
        .number = GetBuddyWalkedResponse_FieldNumber_FamilyCandyId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetBuddyWalkedResponse__storage_, familyCandyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "candyEarnedCount",
        .dataTypeSpecific.className = NULL,
        .number = GetBuddyWalkedResponse_FieldNumber_CandyEarnedCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetBuddyWalkedResponse__storage_, candyEarnedCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBuddyWalkedResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBuddyWalkedResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetBuddyWalkedResponse_FamilyCandyId_RawValue(GetBuddyWalkedResponse *message) {
  GPBDescriptor *descriptor = [GetBuddyWalkedResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetBuddyWalkedResponse_FieldNumber_FamilyCandyId];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetBuddyWalkedResponse_FamilyCandyId_RawValue(GetBuddyWalkedResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetBuddyWalkedResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetBuddyWalkedResponse_FieldNumber_FamilyCandyId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GetDownloadUrlsResponse

@implementation GetDownloadUrlsResponse

@dynamic downloadUrlsArray, downloadUrlsArray_Count;

typedef struct GetDownloadUrlsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *downloadUrlsArray;
} GetDownloadUrlsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "downloadUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DownloadUrlEntry),
        .number = GetDownloadUrlsResponse_FieldNumber_DownloadUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDownloadUrlsResponse__storage_, downloadUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDownloadUrlsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDownloadUrlsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetGymDetailsResponse

@implementation GetGymDetailsResponse

@dynamic hasGymState, gymState;
@dynamic name;
@dynamic urlsArray, urlsArray_Count;
@dynamic result;
@dynamic description_p;
@dynamic secondaryURLArray, secondaryURLArray_Count;

typedef struct GetGymDetailsResponse__storage_ {
  uint32_t _has_storage_[1];
  GetGymDetailsResponse_Result result;
  GymState *gymState;
  NSString *name;
  NSMutableArray *urlsArray;
  NSString *description_p;
  NSMutableArray *secondaryURLArray;
} GetGymDetailsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gymState",
        .dataTypeSpecific.className = GPBStringifySymbol(GymState),
        .number = GetGymDetailsResponse_FieldNumber_GymState,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetGymDetailsResponse__storage_, gymState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsResponse_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetGymDetailsResponse__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "urlsArray",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsResponse_FieldNumber_UrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetGymDetailsResponse__storage_, urlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = GetGymDetailsResponse_Result_EnumDescriptor,
        .number = GetGymDetailsResponse_FieldNumber_Result,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetGymDetailsResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsResponse_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetGymDetailsResponse__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secondaryURLArray",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsResponse_FieldNumber_SecondaryURLArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetGymDetailsResponse__storage_, secondaryURLArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetGymDetailsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetGymDetailsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\000secondary_url\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetGymDetailsResponse_Result_RawValue(GetGymDetailsResponse *message) {
  GPBDescriptor *descriptor = [GetGymDetailsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetGymDetailsResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetGymDetailsResponse_Result_RawValue(GetGymDetailsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetGymDetailsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetGymDetailsResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetGymDetailsResponse_Result

GPBEnumDescriptor *GetGymDetailsResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorNotInRange\000";
    static const int32_t values[] = {
        GetGymDetailsResponse_Result_Unset,
        GetGymDetailsResponse_Result_Success,
        GetGymDetailsResponse_Result_ErrorNotInRange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetGymDetailsResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetGymDetailsResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetGymDetailsResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetGymDetailsResponse_Result_Unset:
    case GetGymDetailsResponse_Result_Success:
    case GetGymDetailsResponse_Result_ErrorNotInRange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetHatchedEggsResponse

@implementation GetHatchedEggsResponse

@dynamic success;
@dynamic pokemonIdArray, pokemonIdArray_Count;
@dynamic experienceAwardedArray, experienceAwardedArray_Count;
@dynamic candyAwardedArray, candyAwardedArray_Count;
@dynamic stardustAwardedArray, stardustAwardedArray_Count;
@dynamic eggKmWalkedArray, eggKmWalkedArray_Count;
@dynamic hatchedPokemonArray, hatchedPokemonArray_Count;

typedef struct GetHatchedEggsResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *pokemonIdArray;
  GPBInt32Array *experienceAwardedArray;
  GPBInt32Array *candyAwardedArray;
  GPBInt32Array *stardustAwardedArray;
  GPBFloatArray *eggKmWalkedArray;
  NSMutableArray *hatchedPokemonArray;
} GetHatchedEggsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = GetHatchedEggsResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pokemonIdArray",
        .dataTypeSpecific.className = NULL,
        .number = GetHatchedEggsResponse_FieldNumber_PokemonIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetHatchedEggsResponse__storage_, pokemonIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "experienceAwardedArray",
        .dataTypeSpecific.className = NULL,
        .number = GetHatchedEggsResponse_FieldNumber_ExperienceAwardedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetHatchedEggsResponse__storage_, experienceAwardedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "candyAwardedArray",
        .dataTypeSpecific.className = NULL,
        .number = GetHatchedEggsResponse_FieldNumber_CandyAwardedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetHatchedEggsResponse__storage_, candyAwardedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stardustAwardedArray",
        .dataTypeSpecific.className = NULL,
        .number = GetHatchedEggsResponse_FieldNumber_StardustAwardedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetHatchedEggsResponse__storage_, stardustAwardedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "eggKmWalkedArray",
        .dataTypeSpecific.className = NULL,
        .number = GetHatchedEggsResponse_FieldNumber_EggKmWalkedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetHatchedEggsResponse__storage_, eggKmWalkedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "hatchedPokemonArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = GetHatchedEggsResponse_FieldNumber_HatchedPokemonArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetHatchedEggsResponse__storage_, hatchedPokemonArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetHatchedEggsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetHatchedEggsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInboxResponse

@implementation GetInboxResponse

@dynamic result;
@dynamic hasInbox, inbox;

typedef struct GetInboxResponse__storage_ {
  uint32_t _has_storage_[1];
  GetInboxResponse_Result result;
  GetInboxResponse_ClientInbox *inbox;
} GetInboxResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = GetInboxResponse_Result_EnumDescriptor,
        .number = GetInboxResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetInboxResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "inbox",
        .dataTypeSpecific.className = GPBStringifySymbol(GetInboxResponse_ClientInbox),
        .number = GetInboxResponse_FieldNumber_Inbox,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetInboxResponse__storage_, inbox),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInboxResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInboxResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetInboxResponse_Result_RawValue(GetInboxResponse *message) {
  GPBDescriptor *descriptor = [GetInboxResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetInboxResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetInboxResponse_Result_RawValue(GetInboxResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetInboxResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetInboxResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetInboxResponse_Result

GPBEnumDescriptor *GetInboxResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Failure\000";
    static const int32_t values[] = {
        GetInboxResponse_Result_Unset,
        GetInboxResponse_Result_Success,
        GetInboxResponse_Result_Failure,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetInboxResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetInboxResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetInboxResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetInboxResponse_Result_Unset:
    case GetInboxResponse_Result_Success:
    case GetInboxResponse_Result_Failure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetInboxResponse_ClientInbox

@implementation GetInboxResponse_ClientInbox

@dynamic notificationsArray, notificationsArray_Count;
@dynamic builtinVariablesArray, builtinVariablesArray_Count;

typedef struct GetInboxResponse_ClientInbox__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *notificationsArray;
  NSMutableArray *builtinVariablesArray;
} GetInboxResponse_ClientInbox__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetInboxResponse_ClientInbox_Notification),
        .number = GetInboxResponse_ClientInbox_FieldNumber_NotificationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox__storage_, notificationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "builtinVariablesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetInboxResponse_ClientInbox_TemplateVariable),
        .number = GetInboxResponse_ClientInbox_FieldNumber_BuiltinVariablesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox__storage_, builtinVariablesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInboxResponse_ClientInbox class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInboxResponse_ClientInbox__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GetInboxResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInboxResponse_ClientInbox_Notification

@implementation GetInboxResponse_ClientInbox_Notification

@dynamic notificationId;
@dynamic bundle;
@dynamic asset;
@dynamic icon;
@dynamic titleKey;
@dynamic category;
@dynamic createTimestampMs;
@dynamic expireTimestampMs;
@dynamic variablesArray, variablesArray_Count;
@dynamic labelsArray, labelsArray_Count;

typedef struct GetInboxResponse_ClientInbox_Notification__storage_ {
  uint32_t _has_storage_[1];
  GetInboxResponse_ClientInbox_Notification_NotificationCategory category;
  NSString *notificationId;
  NSString *bundle;
  NSString *asset;
  NSString *icon;
  NSString *titleKey;
  NSMutableArray *variablesArray;
  GPBEnumArray *labelsArray;
  int64_t createTimestampMs;
  int64_t expireTimestampMs;
} GetInboxResponse_ClientInbox_Notification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationId",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_NotificationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, notificationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundle",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_Bundle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, bundle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "asset",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_Asset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, asset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleKey",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_TitleKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, titleKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.enumDescFunc = GetInboxResponse_ClientInbox_Notification_NotificationCategory_EnumDescriptor,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_Category,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, category),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "createTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_CreateTimestampMs,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, createTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expireTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_ExpireTimestampMs,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, expireTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "variablesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetInboxResponse_ClientInbox_TemplateVariable),
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_VariablesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, variablesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "labelsArray",
        .dataTypeSpecific.enumDescFunc = GetInboxResponse_ClientInbox_Notification_Label_EnumDescriptor,
        .number = GetInboxResponse_ClientInbox_Notification_FieldNumber_LabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_Notification__storage_, labelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInboxResponse_ClientInbox_Notification class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInboxResponse_ClientInbox_Notification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GetInboxResponse_ClientInbox)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetInboxResponse_ClientInbox_Notification_Category_RawValue(GetInboxResponse_ClientInbox_Notification *message) {
  GPBDescriptor *descriptor = [GetInboxResponse_ClientInbox_Notification descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetInboxResponse_ClientInbox_Notification_FieldNumber_Category];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetInboxResponse_ClientInbox_Notification_Category_RawValue(GetInboxResponse_ClientInbox_Notification *message, int32_t value) {
  GPBDescriptor *descriptor = [GetInboxResponse_ClientInbox_Notification descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetInboxResponse_ClientInbox_Notification_FieldNumber_Category];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetInboxResponse_ClientInbox_Notification_Label

GPBEnumDescriptor *GetInboxResponse_ClientInbox_Notification_Label_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnsetLabel\000Unread\000New\000ExpiringSoon\000Immed"
        "iate\000";
    static const int32_t values[] = {
        GetInboxResponse_ClientInbox_Notification_Label_UnsetLabel,
        GetInboxResponse_ClientInbox_Notification_Label_Unread,
        GetInboxResponse_ClientInbox_Notification_Label_New,
        GetInboxResponse_ClientInbox_Notification_Label_ExpiringSoon,
        GetInboxResponse_ClientInbox_Notification_Label_Immediate,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetInboxResponse_ClientInbox_Notification_Label)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetInboxResponse_ClientInbox_Notification_Label_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetInboxResponse_ClientInbox_Notification_Label_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetInboxResponse_ClientInbox_Notification_Label_UnsetLabel:
    case GetInboxResponse_ClientInbox_Notification_Label_Unread:
    case GetInboxResponse_ClientInbox_Notification_Label_New:
    case GetInboxResponse_ClientInbox_Notification_Label_ExpiringSoon:
    case GetInboxResponse_ClientInbox_Notification_Label_Immediate:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GetInboxResponse_ClientInbox_Notification_NotificationCategory

GPBEnumDescriptor *GetInboxResponse_ClientInbox_Notification_NotificationCategory_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnsetCategory\000Marketing\000Announcement\000Adm"
        "inNote\000GameEvent\000";
    static const int32_t values[] = {
        GetInboxResponse_ClientInbox_Notification_NotificationCategory_UnsetCategory,
        GetInboxResponse_ClientInbox_Notification_NotificationCategory_Marketing,
        GetInboxResponse_ClientInbox_Notification_NotificationCategory_Announcement,
        GetInboxResponse_ClientInbox_Notification_NotificationCategory_AdminNote,
        GetInboxResponse_ClientInbox_Notification_NotificationCategory_GameEvent,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetInboxResponse_ClientInbox_Notification_NotificationCategory)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetInboxResponse_ClientInbox_Notification_NotificationCategory_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetInboxResponse_ClientInbox_Notification_NotificationCategory_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetInboxResponse_ClientInbox_Notification_NotificationCategory_UnsetCategory:
    case GetInboxResponse_ClientInbox_Notification_NotificationCategory_Marketing:
    case GetInboxResponse_ClientInbox_Notification_NotificationCategory_Announcement:
    case GetInboxResponse_ClientInbox_Notification_NotificationCategory_AdminNote:
    case GetInboxResponse_ClientInbox_Notification_NotificationCategory_GameEvent:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetInboxResponse_ClientInbox_TemplateVariable

@implementation GetInboxResponse_ClientInbox_TemplateVariable

@dynamic name;
@dynamic value;

typedef struct GetInboxResponse_ClientInbox_TemplateVariable__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
} GetInboxResponse_ClientInbox_TemplateVariable__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_TemplateVariable_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_TemplateVariable__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxResponse_ClientInbox_TemplateVariable_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetInboxResponse_ClientInbox_TemplateVariable__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInboxResponse_ClientInbox_TemplateVariable class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInboxResponse_ClientInbox_TemplateVariable__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GetInboxResponse_ClientInbox)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIncensePokemonResponse

@implementation GetIncensePokemonResponse

@dynamic result;
@dynamic pokemonId;
@dynamic latitude;
@dynamic longitude;
@dynamic encounterLocation;
@dynamic encounterId;
@dynamic disappearTimestampMs;
@dynamic hasPokemonDisplay, pokemonDisplay;

typedef struct GetIncensePokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  GetIncensePokemonResponse_Result result;
  PokemonId pokemonId;
  NSString *encounterLocation;
  PokemonDisplay *pokemonDisplay;
  double latitude;
  double longitude;
  uint64_t encounterId;
  int64_t disappearTimestampMs;
} GetIncensePokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = GetIncensePokemonResponse_Result_EnumDescriptor,
        .number = GetIncensePokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIncensePokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.enumDescFunc = PokemonId_EnumDescriptor,
        .number = GetIncensePokemonResponse_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIncensePokemonResponse__storage_, pokemonId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = GetIncensePokemonResponse_FieldNumber_Latitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetIncensePokemonResponse__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = GetIncensePokemonResponse_FieldNumber_Longitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetIncensePokemonResponse__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "encounterLocation",
        .dataTypeSpecific.className = NULL,
        .number = GetIncensePokemonResponse_FieldNumber_EncounterLocation,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetIncensePokemonResponse__storage_, encounterLocation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encounterId",
        .dataTypeSpecific.className = NULL,
        .number = GetIncensePokemonResponse_FieldNumber_EncounterId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetIncensePokemonResponse__storage_, encounterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "disappearTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = GetIncensePokemonResponse_FieldNumber_DisappearTimestampMs,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetIncensePokemonResponse__storage_, disappearTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pokemonDisplay",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonDisplay),
        .number = GetIncensePokemonResponse_FieldNumber_PokemonDisplay,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetIncensePokemonResponse__storage_, pokemonDisplay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIncensePokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIncensePokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetIncensePokemonResponse_Result_RawValue(GetIncensePokemonResponse *message) {
  GPBDescriptor *descriptor = [GetIncensePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetIncensePokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetIncensePokemonResponse_Result_RawValue(GetIncensePokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetIncensePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetIncensePokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GetIncensePokemonResponse_PokemonId_RawValue(GetIncensePokemonResponse *message) {
  GPBDescriptor *descriptor = [GetIncensePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetIncensePokemonResponse_FieldNumber_PokemonId];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetIncensePokemonResponse_PokemonId_RawValue(GetIncensePokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetIncensePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetIncensePokemonResponse_FieldNumber_PokemonId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetIncensePokemonResponse_Result

GPBEnumDescriptor *GetIncensePokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "IncenseEncounterUnknown\000IncenseEncounter"
        "Available\000IncenseEncounterNotAvailable\000";
    static const int32_t values[] = {
        GetIncensePokemonResponse_Result_IncenseEncounterUnknown,
        GetIncensePokemonResponse_Result_IncenseEncounterAvailable,
        GetIncensePokemonResponse_Result_IncenseEncounterNotAvailable,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetIncensePokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetIncensePokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetIncensePokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetIncensePokemonResponse_Result_IncenseEncounterUnknown:
    case GetIncensePokemonResponse_Result_IncenseEncounterAvailable:
    case GetIncensePokemonResponse_Result_IncenseEncounterNotAvailable:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetInventoryResponse

@implementation GetInventoryResponse

@dynamic success;
@dynamic hasInventoryDelta, inventoryDelta;

typedef struct GetInventoryResponse__storage_ {
  uint32_t _has_storage_[1];
  InventoryDelta *inventoryDelta;
} GetInventoryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = GetInventoryResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "inventoryDelta",
        .dataTypeSpecific.className = GPBStringifySymbol(InventoryDelta),
        .number = GetInventoryResponse_FieldNumber_InventoryDelta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetInventoryResponse__storage_, inventoryDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInventoryResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInventoryResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMapObjectsResponse

@implementation GetMapObjectsResponse

@dynamic mapCellsArray, mapCellsArray_Count;
@dynamic status;
@dynamic timeOfDay;

typedef struct GetMapObjectsResponse__storage_ {
  uint32_t _has_storage_[1];
  MapObjectsStatus status;
  GetMapObjectsResponse_TimeOfDay timeOfDay;
  NSMutableArray *mapCellsArray;
} GetMapObjectsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mapCellsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MapCell),
        .number = GetMapObjectsResponse_FieldNumber_MapCellsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMapObjectsResponse__storage_, mapCellsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = MapObjectsStatus_EnumDescriptor,
        .number = GetMapObjectsResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMapObjectsResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timeOfDay",
        .dataTypeSpecific.enumDescFunc = GetMapObjectsResponse_TimeOfDay_EnumDescriptor,
        .number = GetMapObjectsResponse_FieldNumber_TimeOfDay,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetMapObjectsResponse__storage_, timeOfDay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMapObjectsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMapObjectsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetMapObjectsResponse_Status_RawValue(GetMapObjectsResponse *message) {
  GPBDescriptor *descriptor = [GetMapObjectsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetMapObjectsResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetMapObjectsResponse_Status_RawValue(GetMapObjectsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetMapObjectsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetMapObjectsResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GetMapObjectsResponse_TimeOfDay_RawValue(GetMapObjectsResponse *message) {
  GPBDescriptor *descriptor = [GetMapObjectsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetMapObjectsResponse_FieldNumber_TimeOfDay];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetMapObjectsResponse_TimeOfDay_RawValue(GetMapObjectsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetMapObjectsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetMapObjectsResponse_FieldNumber_TimeOfDay];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetMapObjectsResponse_TimeOfDay

GPBEnumDescriptor *GetMapObjectsResponse_TimeOfDay_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Day\000Night\000";
    static const int32_t values[] = {
        GetMapObjectsResponse_TimeOfDay_None,
        GetMapObjectsResponse_TimeOfDay_Day,
        GetMapObjectsResponse_TimeOfDay_Night,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetMapObjectsResponse_TimeOfDay)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetMapObjectsResponse_TimeOfDay_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetMapObjectsResponse_TimeOfDay_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetMapObjectsResponse_TimeOfDay_None:
    case GetMapObjectsResponse_TimeOfDay_Day:
    case GetMapObjectsResponse_TimeOfDay_Night:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetPlayerProfileResponse

@implementation GetPlayerProfileResponse

@dynamic result;
@dynamic startTime;
@dynamic badgesArray, badgesArray_Count;

typedef struct GetPlayerProfileResponse__storage_ {
  uint32_t _has_storage_[1];
  GetPlayerProfileResponse_Result result;
  NSMutableArray *badgesArray;
  int64_t startTime;
} GetPlayerProfileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = GetPlayerProfileResponse_Result_EnumDescriptor,
        .number = GetPlayerProfileResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPlayerProfileResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = GetPlayerProfileResponse_FieldNumber_StartTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPlayerProfileResponse__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "badgesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerBadge),
        .number = GetPlayerProfileResponse_FieldNumber_BadgesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPlayerProfileResponse__storage_, badgesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPlayerProfileResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPlayerProfileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetPlayerProfileResponse_Result_RawValue(GetPlayerProfileResponse *message) {
  GPBDescriptor *descriptor = [GetPlayerProfileResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetPlayerProfileResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetPlayerProfileResponse_Result_RawValue(GetPlayerProfileResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetPlayerProfileResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetPlayerProfileResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetPlayerProfileResponse_Result

GPBEnumDescriptor *GetPlayerProfileResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000";
    static const int32_t values[] = {
        GetPlayerProfileResponse_Result_Unset,
        GetPlayerProfileResponse_Result_Success,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetPlayerProfileResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetPlayerProfileResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetPlayerProfileResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetPlayerProfileResponse_Result_Unset:
    case GetPlayerProfileResponse_Result_Success:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetPlayerResponse

@implementation GetPlayerResponse

@dynamic success;
@dynamic hasPlayerData, playerData;
@dynamic banned;
@dynamic warn;

typedef struct GetPlayerResponse__storage_ {
  uint32_t _has_storage_[1];
  PlayerData *playerData;
} GetPlayerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = GetPlayerResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "playerData",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerData),
        .number = GetPlayerResponse_FieldNumber_PlayerData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetPlayerResponse__storage_, playerData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "banned",
        .dataTypeSpecific.className = NULL,
        .number = GetPlayerResponse_FieldNumber_Banned,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "warn",
        .dataTypeSpecific.className = NULL,
        .number = GetPlayerResponse_FieldNumber_Warn,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPlayerResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPlayerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IncenseEncounterResponse

@implementation IncenseEncounterResponse

@dynamic result;
@dynamic hasPokemonData, pokemonData;
@dynamic hasCaptureProbability, captureProbability;
@dynamic activeItem;

typedef struct IncenseEncounterResponse__storage_ {
  uint32_t _has_storage_[1];
  IncenseEncounterResponse_Result result;
  ItemId activeItem;
  PokemonData *pokemonData;
  CaptureProbability *captureProbability;
} IncenseEncounterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = IncenseEncounterResponse_Result_EnumDescriptor,
        .number = IncenseEncounterResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IncenseEncounterResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonData",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = IncenseEncounterResponse_FieldNumber_PokemonData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IncenseEncounterResponse__storage_, pokemonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "captureProbability",
        .dataTypeSpecific.className = GPBStringifySymbol(CaptureProbability),
        .number = IncenseEncounterResponse_FieldNumber_CaptureProbability,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IncenseEncounterResponse__storage_, captureProbability),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activeItem",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = IncenseEncounterResponse_FieldNumber_ActiveItem,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IncenseEncounterResponse__storage_, activeItem),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IncenseEncounterResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncenseEncounterResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IncenseEncounterResponse_Result_RawValue(IncenseEncounterResponse *message) {
  GPBDescriptor *descriptor = [IncenseEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IncenseEncounterResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetIncenseEncounterResponse_Result_RawValue(IncenseEncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [IncenseEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IncenseEncounterResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t IncenseEncounterResponse_ActiveItem_RawValue(IncenseEncounterResponse *message) {
  GPBDescriptor *descriptor = [IncenseEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IncenseEncounterResponse_FieldNumber_ActiveItem];
  return GPBGetMessageInt32Field(message, field);
}

void SetIncenseEncounterResponse_ActiveItem_RawValue(IncenseEncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [IncenseEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IncenseEncounterResponse_FieldNumber_ActiveItem];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum IncenseEncounterResponse_Result

GPBEnumDescriptor *IncenseEncounterResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "IncenseEncounterUnknown\000IncenseEncounter"
        "Success\000IncenseEncounterNotAvailable\000Pok"
        "emonInventoryFull\000";
    static const int32_t values[] = {
        IncenseEncounterResponse_Result_IncenseEncounterUnknown,
        IncenseEncounterResponse_Result_IncenseEncounterSuccess,
        IncenseEncounterResponse_Result_IncenseEncounterNotAvailable,
        IncenseEncounterResponse_Result_PokemonInventoryFull,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(IncenseEncounterResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:IncenseEncounterResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL IncenseEncounterResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case IncenseEncounterResponse_Result_IncenseEncounterUnknown:
    case IncenseEncounterResponse_Result_IncenseEncounterSuccess:
    case IncenseEncounterResponse_Result_IncenseEncounterNotAvailable:
    case IncenseEncounterResponse_Result_PokemonInventoryFull:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - LevelUpRewardsResponse

@implementation LevelUpRewardsResponse

@dynamic result;
@dynamic itemsAwardedArray, itemsAwardedArray_Count;
@dynamic itemsUnlockedArray, itemsUnlockedArray_Count;
@dynamic avatarTemplateIdsArray, avatarTemplateIdsArray_Count;

typedef struct LevelUpRewardsResponse__storage_ {
  uint32_t _has_storage_[1];
  LevelUpRewardsResponse_Result result;
  NSMutableArray *itemsAwardedArray;
  GPBEnumArray *itemsUnlockedArray;
  NSMutableArray *avatarTemplateIdsArray;
} LevelUpRewardsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = LevelUpRewardsResponse_Result_EnumDescriptor,
        .number = LevelUpRewardsResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LevelUpRewardsResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "itemsAwardedArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ItemAward),
        .number = LevelUpRewardsResponse_FieldNumber_ItemsAwardedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LevelUpRewardsResponse__storage_, itemsAwardedArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "itemsUnlockedArray",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = LevelUpRewardsResponse_FieldNumber_ItemsUnlockedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LevelUpRewardsResponse__storage_, itemsUnlockedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "avatarTemplateIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = LevelUpRewardsResponse_FieldNumber_AvatarTemplateIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LevelUpRewardsResponse__storage_, avatarTemplateIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LevelUpRewardsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LevelUpRewardsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LevelUpRewardsResponse_Result_RawValue(LevelUpRewardsResponse *message) {
  GPBDescriptor *descriptor = [LevelUpRewardsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LevelUpRewardsResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetLevelUpRewardsResponse_Result_RawValue(LevelUpRewardsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [LevelUpRewardsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LevelUpRewardsResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum LevelUpRewardsResponse_Result

GPBEnumDescriptor *LevelUpRewardsResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000AwardedAlready\000";
    static const int32_t values[] = {
        LevelUpRewardsResponse_Result_Unset,
        LevelUpRewardsResponse_Result_Success,
        LevelUpRewardsResponse_Result_AwardedAlready,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LevelUpRewardsResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LevelUpRewardsResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LevelUpRewardsResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case LevelUpRewardsResponse_Result_Unset:
    case LevelUpRewardsResponse_Result_Success:
    case LevelUpRewardsResponse_Result_AwardedAlready:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ListAvatarCustomizationsResponse

@implementation ListAvatarCustomizationsResponse

@dynamic result;
@dynamic hasAvatarCustomizations, avatarCustomizations;

typedef struct ListAvatarCustomizationsResponse__storage_ {
  uint32_t _has_storage_[1];
  ListAvatarCustomizationsResponse_Result result;
  AvatarCustomization *avatarCustomizations;
} ListAvatarCustomizationsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ListAvatarCustomizationsResponse_Result_EnumDescriptor,
        .number = ListAvatarCustomizationsResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListAvatarCustomizationsResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "avatarCustomizations",
        .dataTypeSpecific.className = GPBStringifySymbol(AvatarCustomization),
        .number = ListAvatarCustomizationsResponse_FieldNumber_AvatarCustomizations,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ListAvatarCustomizationsResponse__storage_, avatarCustomizations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListAvatarCustomizationsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListAvatarCustomizationsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ListAvatarCustomizationsResponse_Result_RawValue(ListAvatarCustomizationsResponse *message) {
  GPBDescriptor *descriptor = [ListAvatarCustomizationsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ListAvatarCustomizationsResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetListAvatarCustomizationsResponse_Result_RawValue(ListAvatarCustomizationsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ListAvatarCustomizationsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ListAvatarCustomizationsResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ListAvatarCustomizationsResponse_Result

GPBEnumDescriptor *ListAvatarCustomizationsResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Failure\000";
    static const int32_t values[] = {
        ListAvatarCustomizationsResponse_Result_Unset,
        ListAvatarCustomizationsResponse_Result_Success,
        ListAvatarCustomizationsResponse_Result_Failure,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ListAvatarCustomizationsResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ListAvatarCustomizationsResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ListAvatarCustomizationsResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case ListAvatarCustomizationsResponse_Result_Unset:
    case ListAvatarCustomizationsResponse_Result_Success:
    case ListAvatarCustomizationsResponse_Result_Failure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MarkTutorialCompleteResponse

@implementation MarkTutorialCompleteResponse

@dynamic success;
@dynamic hasPlayerData, playerData;

typedef struct MarkTutorialCompleteResponse__storage_ {
  uint32_t _has_storage_[1];
  PlayerData *playerData;
} MarkTutorialCompleteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = MarkTutorialCompleteResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "playerData",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerData),
        .number = MarkTutorialCompleteResponse_FieldNumber_PlayerData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MarkTutorialCompleteResponse__storage_, playerData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MarkTutorialCompleteResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarkTutorialCompleteResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NicknamePokemonResponse

@implementation NicknamePokemonResponse

@dynamic result;

typedef struct NicknamePokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  NicknamePokemonResponse_Result result;
} NicknamePokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = NicknamePokemonResponse_Result_EnumDescriptor,
        .number = NicknamePokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NicknamePokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NicknamePokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NicknamePokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NicknamePokemonResponse_Result_RawValue(NicknamePokemonResponse *message) {
  GPBDescriptor *descriptor = [NicknamePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NicknamePokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetNicknamePokemonResponse_Result_RawValue(NicknamePokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [NicknamePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NicknamePokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum NicknamePokemonResponse_Result

GPBEnumDescriptor *NicknamePokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorInvalidNickname\000Error"
        "PokemonNotFound\000ErrorPokemonIsEgg\000";
    static const int32_t values[] = {
        NicknamePokemonResponse_Result_Unset,
        NicknamePokemonResponse_Result_Success,
        NicknamePokemonResponse_Result_ErrorInvalidNickname,
        NicknamePokemonResponse_Result_ErrorPokemonNotFound,
        NicknamePokemonResponse_Result_ErrorPokemonIsEgg,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NicknamePokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NicknamePokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NicknamePokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case NicknamePokemonResponse_Result_Unset:
    case NicknamePokemonResponse_Result_Success:
    case NicknamePokemonResponse_Result_ErrorInvalidNickname:
    case NicknamePokemonResponse_Result_ErrorPokemonNotFound:
    case NicknamePokemonResponse_Result_ErrorPokemonIsEgg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RecycleInventoryItemResponse

@implementation RecycleInventoryItemResponse

@dynamic result;
@dynamic newCount;

typedef struct RecycleInventoryItemResponse__storage_ {
  uint32_t _has_storage_[1];
  RecycleInventoryItemResponse_Result result;
  int32_t newCount;
} RecycleInventoryItemResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = RecycleInventoryItemResponse_Result_EnumDescriptor,
        .number = RecycleInventoryItemResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecycleInventoryItemResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "newCount",
        .dataTypeSpecific.className = NULL,
        .number = RecycleInventoryItemResponse_FieldNumber_NewCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RecycleInventoryItemResponse__storage_, newCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecycleInventoryItemResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecycleInventoryItemResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RecycleInventoryItemResponse_Result_RawValue(RecycleInventoryItemResponse *message) {
  GPBDescriptor *descriptor = [RecycleInventoryItemResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RecycleInventoryItemResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetRecycleInventoryItemResponse_Result_RawValue(RecycleInventoryItemResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RecycleInventoryItemResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RecycleInventoryItemResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RecycleInventoryItemResponse_Result

GPBEnumDescriptor *RecycleInventoryItemResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorNotEnoughCopies\000Error"
        "CannotRecycleIncubators\000";
    static const int32_t values[] = {
        RecycleInventoryItemResponse_Result_Unset,
        RecycleInventoryItemResponse_Result_Success,
        RecycleInventoryItemResponse_Result_ErrorNotEnoughCopies,
        RecycleInventoryItemResponse_Result_ErrorCannotRecycleIncubators,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RecycleInventoryItemResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RecycleInventoryItemResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RecycleInventoryItemResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case RecycleInventoryItemResponse_Result_Unset:
    case RecycleInventoryItemResponse_Result_Success:
    case RecycleInventoryItemResponse_Result_ErrorNotEnoughCopies:
    case RecycleInventoryItemResponse_Result_ErrorCannotRecycleIncubators:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RegisterBackgroundDeviceResponse

@implementation RegisterBackgroundDeviceResponse

@dynamic status;
@dynamic hasToken, token;

typedef struct RegisterBackgroundDeviceResponse__storage_ {
  uint32_t _has_storage_[1];
  RegisterBackgroundDeviceResponse_Status status;
  BackgroundToken *token;
} RegisterBackgroundDeviceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = RegisterBackgroundDeviceResponse_Status_EnumDescriptor,
        .number = RegisterBackgroundDeviceResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterBackgroundDeviceResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = GPBStringifySymbol(BackgroundToken),
        .number = RegisterBackgroundDeviceResponse_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterBackgroundDeviceResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterBackgroundDeviceResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterBackgroundDeviceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RegisterBackgroundDeviceResponse_Status_RawValue(RegisterBackgroundDeviceResponse *message) {
  GPBDescriptor *descriptor = [RegisterBackgroundDeviceResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RegisterBackgroundDeviceResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetRegisterBackgroundDeviceResponse_Status_RawValue(RegisterBackgroundDeviceResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RegisterBackgroundDeviceResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RegisterBackgroundDeviceResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RegisterBackgroundDeviceResponse_Status

GPBEnumDescriptor *RegisterBackgroundDeviceResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Error\000";
    static const int32_t values[] = {
        RegisterBackgroundDeviceResponse_Status_Unset,
        RegisterBackgroundDeviceResponse_Status_Success,
        RegisterBackgroundDeviceResponse_Status_Error,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RegisterBackgroundDeviceResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RegisterBackgroundDeviceResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RegisterBackgroundDeviceResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case RegisterBackgroundDeviceResponse_Status_Unset:
    case RegisterBackgroundDeviceResponse_Status_Success:
    case RegisterBackgroundDeviceResponse_Status_Error:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ReleasePokemonResponse

@implementation ReleasePokemonResponse

@dynamic result;
@dynamic candyAwarded;

typedef struct ReleasePokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  ReleasePokemonResponse_Result result;
  int32_t candyAwarded;
} ReleasePokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ReleasePokemonResponse_Result_EnumDescriptor,
        .number = ReleasePokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReleasePokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "candyAwarded",
        .dataTypeSpecific.className = NULL,
        .number = ReleasePokemonResponse_FieldNumber_CandyAwarded,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReleasePokemonResponse__storage_, candyAwarded),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReleasePokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReleasePokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ReleasePokemonResponse_Result_RawValue(ReleasePokemonResponse *message) {
  GPBDescriptor *descriptor = [ReleasePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ReleasePokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetReleasePokemonResponse_Result_RawValue(ReleasePokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ReleasePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ReleasePokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ReleasePokemonResponse_Result

GPBEnumDescriptor *ReleasePokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000PokemonDeployed\000Failed\000Err"
        "orPokemonIsEgg\000ErrorPokemonIsBuddy\000";
    static const int32_t values[] = {
        ReleasePokemonResponse_Result_Unset,
        ReleasePokemonResponse_Result_Success,
        ReleasePokemonResponse_Result_PokemonDeployed,
        ReleasePokemonResponse_Result_Failed,
        ReleasePokemonResponse_Result_ErrorPokemonIsEgg,
        ReleasePokemonResponse_Result_ErrorPokemonIsBuddy,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReleasePokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ReleasePokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ReleasePokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case ReleasePokemonResponse_Result_Unset:
    case ReleasePokemonResponse_Result_Success:
    case ReleasePokemonResponse_Result_PokemonDeployed:
    case ReleasePokemonResponse_Result_Failed:
    case ReleasePokemonResponse_Result_ErrorPokemonIsEgg:
    case ReleasePokemonResponse_Result_ErrorPokemonIsBuddy:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SetAvatarItemAsViewedResponse

@implementation SetAvatarItemAsViewedResponse

@dynamic result;

typedef struct SetAvatarItemAsViewedResponse__storage_ {
  uint32_t _has_storage_[1];
  SetAvatarItemAsViewedResponse_Result result;
} SetAvatarItemAsViewedResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = SetAvatarItemAsViewedResponse_Result_EnumDescriptor,
        .number = SetAvatarItemAsViewedResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetAvatarItemAsViewedResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAvatarItemAsViewedResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAvatarItemAsViewedResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SetAvatarItemAsViewedResponse_Result_RawValue(SetAvatarItemAsViewedResponse *message) {
  GPBDescriptor *descriptor = [SetAvatarItemAsViewedResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetAvatarItemAsViewedResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetSetAvatarItemAsViewedResponse_Result_RawValue(SetAvatarItemAsViewedResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SetAvatarItemAsViewedResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetAvatarItemAsViewedResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SetAvatarItemAsViewedResponse_Result

GPBEnumDescriptor *SetAvatarItemAsViewedResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Failure\000";
    static const int32_t values[] = {
        SetAvatarItemAsViewedResponse_Result_Unset,
        SetAvatarItemAsViewedResponse_Result_Success,
        SetAvatarItemAsViewedResponse_Result_Failure,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SetAvatarItemAsViewedResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SetAvatarItemAsViewedResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SetAvatarItemAsViewedResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case SetAvatarItemAsViewedResponse_Result_Unset:
    case SetAvatarItemAsViewedResponse_Result_Success:
    case SetAvatarItemAsViewedResponse_Result_Failure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SetAvatarResponse

@implementation SetAvatarResponse

@dynamic status;
@dynamic hasPlayerData, playerData;

typedef struct SetAvatarResponse__storage_ {
  uint32_t _has_storage_[1];
  SetAvatarResponse_Status status;
  PlayerData *playerData;
} SetAvatarResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = SetAvatarResponse_Status_EnumDescriptor,
        .number = SetAvatarResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetAvatarResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerData",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerData),
        .number = SetAvatarResponse_FieldNumber_PlayerData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetAvatarResponse__storage_, playerData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAvatarResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAvatarResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SetAvatarResponse_Status_RawValue(SetAvatarResponse *message) {
  GPBDescriptor *descriptor = [SetAvatarResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetAvatarResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetSetAvatarResponse_Status_RawValue(SetAvatarResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SetAvatarResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetAvatarResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SetAvatarResponse_Status

GPBEnumDescriptor *SetAvatarResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000AvatarAlreadySet\000Failure\000S"
        "lotNotAllowed\000ItemNotOwned\000InvalidAvatar"
        "Type\000";
    static const int32_t values[] = {
        SetAvatarResponse_Status_Unset,
        SetAvatarResponse_Status_Success,
        SetAvatarResponse_Status_AvatarAlreadySet,
        SetAvatarResponse_Status_Failure,
        SetAvatarResponse_Status_SlotNotAllowed,
        SetAvatarResponse_Status_ItemNotOwned,
        SetAvatarResponse_Status_InvalidAvatarType,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SetAvatarResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SetAvatarResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SetAvatarResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case SetAvatarResponse_Status_Unset:
    case SetAvatarResponse_Status_Success:
    case SetAvatarResponse_Status_AvatarAlreadySet:
    case SetAvatarResponse_Status_Failure:
    case SetAvatarResponse_Status_SlotNotAllowed:
    case SetAvatarResponse_Status_ItemNotOwned:
    case SetAvatarResponse_Status_InvalidAvatarType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SetBuddyPokemonResponse

@implementation SetBuddyPokemonResponse

@dynamic result;
@dynamic hasUpdatedBuddy, updatedBuddy;

typedef struct SetBuddyPokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  SetBuddyPokemonResponse_Result result;
  BuddyPokemon *updatedBuddy;
} SetBuddyPokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = SetBuddyPokemonResponse_Result_EnumDescriptor,
        .number = SetBuddyPokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetBuddyPokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "updatedBuddy",
        .dataTypeSpecific.className = GPBStringifySymbol(BuddyPokemon),
        .number = SetBuddyPokemonResponse_FieldNumber_UpdatedBuddy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetBuddyPokemonResponse__storage_, updatedBuddy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetBuddyPokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetBuddyPokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SetBuddyPokemonResponse_Result_RawValue(SetBuddyPokemonResponse *message) {
  GPBDescriptor *descriptor = [SetBuddyPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetBuddyPokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetSetBuddyPokemonResponse_Result_RawValue(SetBuddyPokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SetBuddyPokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetBuddyPokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SetBuddyPokemonResponse_Result

GPBEnumDescriptor *SetBuddyPokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unest\000Success\000ErrorPokemonDeployed\000Error"
        "PokemonNotOwned\000ErrorPokemonIsEgg\000";
    static const int32_t values[] = {
        SetBuddyPokemonResponse_Result_Unest,
        SetBuddyPokemonResponse_Result_Success,
        SetBuddyPokemonResponse_Result_ErrorPokemonDeployed,
        SetBuddyPokemonResponse_Result_ErrorPokemonNotOwned,
        SetBuddyPokemonResponse_Result_ErrorPokemonIsEgg,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SetBuddyPokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SetBuddyPokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SetBuddyPokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case SetBuddyPokemonResponse_Result_Unest:
    case SetBuddyPokemonResponse_Result_Success:
    case SetBuddyPokemonResponse_Result_ErrorPokemonDeployed:
    case SetBuddyPokemonResponse_Result_ErrorPokemonNotOwned:
    case SetBuddyPokemonResponse_Result_ErrorPokemonIsEgg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SetContactSettingsResponse

@implementation SetContactSettingsResponse

@dynamic status;
@dynamic hasPlayerData, playerData;

typedef struct SetContactSettingsResponse__storage_ {
  uint32_t _has_storage_[1];
  SetContactSettingsResponse_Status status;
  PlayerData *playerData;
} SetContactSettingsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = SetContactSettingsResponse_Status_EnumDescriptor,
        .number = SetContactSettingsResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetContactSettingsResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerData",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerData),
        .number = SetContactSettingsResponse_FieldNumber_PlayerData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetContactSettingsResponse__storage_, playerData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetContactSettingsResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetContactSettingsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SetContactSettingsResponse_Status_RawValue(SetContactSettingsResponse *message) {
  GPBDescriptor *descriptor = [SetContactSettingsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetContactSettingsResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetSetContactSettingsResponse_Status_RawValue(SetContactSettingsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SetContactSettingsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetContactSettingsResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SetContactSettingsResponse_Status

GPBEnumDescriptor *SetContactSettingsResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000Failure\000";
    static const int32_t values[] = {
        SetContactSettingsResponse_Status_Unset,
        SetContactSettingsResponse_Status_Success,
        SetContactSettingsResponse_Status_Failure,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SetContactSettingsResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SetContactSettingsResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SetContactSettingsResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case SetContactSettingsResponse_Status_Unset:
    case SetContactSettingsResponse_Status_Success:
    case SetContactSettingsResponse_Status_Failure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SetFavoritePokemonResponse

@implementation SetFavoritePokemonResponse

@dynamic result;

typedef struct SetFavoritePokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  SetFavoritePokemonResponse_Result result;
} SetFavoritePokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = SetFavoritePokemonResponse_Result_EnumDescriptor,
        .number = SetFavoritePokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetFavoritePokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetFavoritePokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetFavoritePokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SetFavoritePokemonResponse_Result_RawValue(SetFavoritePokemonResponse *message) {
  GPBDescriptor *descriptor = [SetFavoritePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetFavoritePokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetSetFavoritePokemonResponse_Result_RawValue(SetFavoritePokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SetFavoritePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetFavoritePokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SetFavoritePokemonResponse_Result

GPBEnumDescriptor *SetFavoritePokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorPokemonNotFound\000Error"
        "PokemonIsEgg\000";
    static const int32_t values[] = {
        SetFavoritePokemonResponse_Result_Unset,
        SetFavoritePokemonResponse_Result_Success,
        SetFavoritePokemonResponse_Result_ErrorPokemonNotFound,
        SetFavoritePokemonResponse_Result_ErrorPokemonIsEgg,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SetFavoritePokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SetFavoritePokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SetFavoritePokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case SetFavoritePokemonResponse_Result_Unset:
    case SetFavoritePokemonResponse_Result_Success:
    case SetFavoritePokemonResponse_Result_ErrorPokemonNotFound:
    case SetFavoritePokemonResponse_Result_ErrorPokemonIsEgg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SetPlayerTeamResponse

@implementation SetPlayerTeamResponse

@dynamic status;
@dynamic hasPlayerData, playerData;

typedef struct SetPlayerTeamResponse__storage_ {
  uint32_t _has_storage_[1];
  SetPlayerTeamResponse_Status status;
  PlayerData *playerData;
} SetPlayerTeamResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = SetPlayerTeamResponse_Status_EnumDescriptor,
        .number = SetPlayerTeamResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetPlayerTeamResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerData",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerData),
        .number = SetPlayerTeamResponse_FieldNumber_PlayerData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetPlayerTeamResponse__storage_, playerData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetPlayerTeamResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetPlayerTeamResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SetPlayerTeamResponse_Status_RawValue(SetPlayerTeamResponse *message) {
  GPBDescriptor *descriptor = [SetPlayerTeamResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetPlayerTeamResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetSetPlayerTeamResponse_Status_RawValue(SetPlayerTeamResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SetPlayerTeamResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetPlayerTeamResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SetPlayerTeamResponse_Status

GPBEnumDescriptor *SetPlayerTeamResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000TeamAlreadySet\000Failure\000";
    static const int32_t values[] = {
        SetPlayerTeamResponse_Status_Unset,
        SetPlayerTeamResponse_Status_Success,
        SetPlayerTeamResponse_Status_TeamAlreadySet,
        SetPlayerTeamResponse_Status_Failure,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SetPlayerTeamResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SetPlayerTeamResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SetPlayerTeamResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case SetPlayerTeamResponse_Status_Unset:
    case SetPlayerTeamResponse_Status_Success:
    case SetPlayerTeamResponse_Status_TeamAlreadySet:
    case SetPlayerTeamResponse_Status_Failure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SfidaActionLogResponse

@implementation SfidaActionLogResponse

@dynamic result;
@dynamic logEntriesArray, logEntriesArray_Count;

typedef struct SfidaActionLogResponse__storage_ {
  uint32_t _has_storage_[1];
  SfidaActionLogResponse_Result result;
  NSMutableArray *logEntriesArray;
} SfidaActionLogResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = SfidaActionLogResponse_Result_EnumDescriptor,
        .number = SfidaActionLogResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SfidaActionLogResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "logEntriesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ActionLogEntry),
        .number = SfidaActionLogResponse_FieldNumber_LogEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SfidaActionLogResponse__storage_, logEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SfidaActionLogResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SfidaActionLogResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SfidaActionLogResponse_Result_RawValue(SfidaActionLogResponse *message) {
  GPBDescriptor *descriptor = [SfidaActionLogResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SfidaActionLogResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetSfidaActionLogResponse_Result_RawValue(SfidaActionLogResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SfidaActionLogResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SfidaActionLogResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SfidaActionLogResponse_Result

GPBEnumDescriptor *SfidaActionLogResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000";
    static const int32_t values[] = {
        SfidaActionLogResponse_Result_Unset,
        SfidaActionLogResponse_Result_Success,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SfidaActionLogResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SfidaActionLogResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SfidaActionLogResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case SfidaActionLogResponse_Result_Unset:
    case SfidaActionLogResponse_Result_Success:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - StartGymBattleResponse

@implementation StartGymBattleResponse

@dynamic result;
@dynamic battleStartTimestampMs;
@dynamic battleEndTimestampMs;
@dynamic battleId;
@dynamic hasDefender, defender;
@dynamic hasBattleLog, battleLog;
@dynamic hasAttacker, attacker;

typedef struct StartGymBattleResponse__storage_ {
  uint32_t _has_storage_[1];
  StartGymBattleResponse_Result result;
  NSString *battleId;
  BattleParticipant *defender;
  BattleLog *battleLog;
  BattleParticipant *attacker;
  int64_t battleStartTimestampMs;
  int64_t battleEndTimestampMs;
} StartGymBattleResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = StartGymBattleResponse_Result_EnumDescriptor,
        .number = StartGymBattleResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StartGymBattleResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "battleStartTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = StartGymBattleResponse_FieldNumber_BattleStartTimestampMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StartGymBattleResponse__storage_, battleStartTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "battleEndTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = StartGymBattleResponse_FieldNumber_BattleEndTimestampMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StartGymBattleResponse__storage_, battleEndTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "battleId",
        .dataTypeSpecific.className = NULL,
        .number = StartGymBattleResponse_FieldNumber_BattleId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StartGymBattleResponse__storage_, battleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "defender",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleParticipant),
        .number = StartGymBattleResponse_FieldNumber_Defender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(StartGymBattleResponse__storage_, defender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "battleLog",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleLog),
        .number = StartGymBattleResponse_FieldNumber_BattleLog,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(StartGymBattleResponse__storage_, battleLog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attacker",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleParticipant),
        .number = StartGymBattleResponse_FieldNumber_Attacker,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(StartGymBattleResponse__storage_, attacker),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StartGymBattleResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StartGymBattleResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t StartGymBattleResponse_Result_RawValue(StartGymBattleResponse *message) {
  GPBDescriptor *descriptor = [StartGymBattleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StartGymBattleResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetStartGymBattleResponse_Result_RawValue(StartGymBattleResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [StartGymBattleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StartGymBattleResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum StartGymBattleResponse_Result

GPBEnumDescriptor *StartGymBattleResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorGymNotFound\000ErrorGymN"
        "eutral\000ErrorGymWrongTeam\000ErrorGymEmpty\000E"
        "rrorInvalidDefender\000ErrorTrainingInvalid"
        "AttackerCount\000ErrorAllPokemonFainted\000Err"
        "orTooManyBattles\000ErrorTooManyPlayers\000Err"
        "orGymBattleLockout\000ErrorPlayerBelowMinim"
        "umLevel\000ErrorNotInRange\000ErrorPoiInaccess"
        "ible\000";
    static const int32_t values[] = {
        StartGymBattleResponse_Result_Unset,
        StartGymBattleResponse_Result_Success,
        StartGymBattleResponse_Result_ErrorGymNotFound,
        StartGymBattleResponse_Result_ErrorGymNeutral,
        StartGymBattleResponse_Result_ErrorGymWrongTeam,
        StartGymBattleResponse_Result_ErrorGymEmpty,
        StartGymBattleResponse_Result_ErrorInvalidDefender,
        StartGymBattleResponse_Result_ErrorTrainingInvalidAttackerCount,
        StartGymBattleResponse_Result_ErrorAllPokemonFainted,
        StartGymBattleResponse_Result_ErrorTooManyBattles,
        StartGymBattleResponse_Result_ErrorTooManyPlayers,
        StartGymBattleResponse_Result_ErrorGymBattleLockout,
        StartGymBattleResponse_Result_ErrorPlayerBelowMinimumLevel,
        StartGymBattleResponse_Result_ErrorNotInRange,
        StartGymBattleResponse_Result_ErrorPoiInaccessible,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(StartGymBattleResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:StartGymBattleResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL StartGymBattleResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case StartGymBattleResponse_Result_Unset:
    case StartGymBattleResponse_Result_Success:
    case StartGymBattleResponse_Result_ErrorGymNotFound:
    case StartGymBattleResponse_Result_ErrorGymNeutral:
    case StartGymBattleResponse_Result_ErrorGymWrongTeam:
    case StartGymBattleResponse_Result_ErrorGymEmpty:
    case StartGymBattleResponse_Result_ErrorInvalidDefender:
    case StartGymBattleResponse_Result_ErrorTrainingInvalidAttackerCount:
    case StartGymBattleResponse_Result_ErrorAllPokemonFainted:
    case StartGymBattleResponse_Result_ErrorTooManyBattles:
    case StartGymBattleResponse_Result_ErrorTooManyPlayers:
    case StartGymBattleResponse_Result_ErrorGymBattleLockout:
    case StartGymBattleResponse_Result_ErrorPlayerBelowMinimumLevel:
    case StartGymBattleResponse_Result_ErrorNotInRange:
    case StartGymBattleResponse_Result_ErrorPoiInaccessible:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UpdateNotificationResponse

@implementation UpdateNotificationResponse

@dynamic notificationIdsArray, notificationIdsArray_Count;
@dynamic createTimestampMsArray, createTimestampMsArray_Count;
@dynamic state;

typedef struct UpdateNotificationResponse__storage_ {
  uint32_t _has_storage_[1];
  NotificationState state;
  NSMutableArray *notificationIdsArray;
  GPBInt64Array *createTimestampMsArray;
} UpdateNotificationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = UpdateNotificationResponse_FieldNumber_NotificationIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateNotificationResponse__storage_, notificationIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTimestampMsArray",
        .dataTypeSpecific.className = NULL,
        .number = UpdateNotificationResponse_FieldNumber_CreateTimestampMsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateNotificationResponse__storage_, createTimestampMsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = NotificationState_EnumDescriptor,
        .number = UpdateNotificationResponse_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateNotificationResponse__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateNotificationResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateNotificationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UpdateNotificationResponse_State_RawValue(UpdateNotificationResponse *message) {
  GPBDescriptor *descriptor = [UpdateNotificationResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdateNotificationResponse_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetUpdateNotificationResponse_State_RawValue(UpdateNotificationResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UpdateNotificationResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdateNotificationResponse_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UpgradePokemonResponse

@implementation UpgradePokemonResponse

@dynamic result;
@dynamic hasUpgradedPokemon, upgradedPokemon;

typedef struct UpgradePokemonResponse__storage_ {
  uint32_t _has_storage_[1];
  UpgradePokemonResponse_Result result;
  PokemonData *upgradedPokemon;
} UpgradePokemonResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = UpgradePokemonResponse_Result_EnumDescriptor,
        .number = UpgradePokemonResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpgradePokemonResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "upgradedPokemon",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = UpgradePokemonResponse_FieldNumber_UpgradedPokemon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpgradePokemonResponse__storage_, upgradedPokemon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpgradePokemonResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpgradePokemonResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UpgradePokemonResponse_Result_RawValue(UpgradePokemonResponse *message) {
  GPBDescriptor *descriptor = [UpgradePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpgradePokemonResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetUpgradePokemonResponse_Result_RawValue(UpgradePokemonResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UpgradePokemonResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpgradePokemonResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UpgradePokemonResponse_Result

GPBEnumDescriptor *UpgradePokemonResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorPokemonNotFound\000Error"
        "InsufficientResources\000ErrorUpgradeNotAva"
        "ilable\000ErrorPokemonIsDeployed\000";
    static const int32_t values[] = {
        UpgradePokemonResponse_Result_Unset,
        UpgradePokemonResponse_Result_Success,
        UpgradePokemonResponse_Result_ErrorPokemonNotFound,
        UpgradePokemonResponse_Result_ErrorInsufficientResources,
        UpgradePokemonResponse_Result_ErrorUpgradeNotAvailable,
        UpgradePokemonResponse_Result_ErrorPokemonIsDeployed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UpgradePokemonResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UpgradePokemonResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UpgradePokemonResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case UpgradePokemonResponse_Result_Unset:
    case UpgradePokemonResponse_Result_Success:
    case UpgradePokemonResponse_Result_ErrorPokemonNotFound:
    case UpgradePokemonResponse_Result_ErrorInsufficientResources:
    case UpgradePokemonResponse_Result_ErrorUpgradeNotAvailable:
    case UpgradePokemonResponse_Result_ErrorPokemonIsDeployed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UseIncenseResponse

@implementation UseIncenseResponse

@dynamic result;
@dynamic hasAppliedIncense, appliedIncense;

typedef struct UseIncenseResponse__storage_ {
  uint32_t _has_storage_[1];
  UseIncenseResponse_Result result;
  AppliedItem *appliedIncense;
} UseIncenseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = UseIncenseResponse_Result_EnumDescriptor,
        .number = UseIncenseResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseIncenseResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "appliedIncense",
        .dataTypeSpecific.className = GPBStringifySymbol(AppliedItem),
        .number = UseIncenseResponse_FieldNumber_AppliedIncense,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseIncenseResponse__storage_, appliedIncense),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseIncenseResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseIncenseResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseIncenseResponse_Result_RawValue(UseIncenseResponse *message) {
  GPBDescriptor *descriptor = [UseIncenseResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseIncenseResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseIncenseResponse_Result_RawValue(UseIncenseResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UseIncenseResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseIncenseResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UseIncenseResponse_Result

GPBEnumDescriptor *UseIncenseResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Success\000IncenseAlreadyActive\000Non"
        "eInInventory\000LocationUnset\000";
    static const int32_t values[] = {
        UseIncenseResponse_Result_Unknown,
        UseIncenseResponse_Result_Success,
        UseIncenseResponse_Result_IncenseAlreadyActive,
        UseIncenseResponse_Result_NoneInInventory,
        UseIncenseResponse_Result_LocationUnset,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UseIncenseResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UseIncenseResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UseIncenseResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case UseIncenseResponse_Result_Unknown:
    case UseIncenseResponse_Result_Success:
    case UseIncenseResponse_Result_IncenseAlreadyActive:
    case UseIncenseResponse_Result_NoneInInventory:
    case UseIncenseResponse_Result_LocationUnset:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UseItemCaptureResponse

@implementation UseItemCaptureResponse

@dynamic success;
@dynamic itemCaptureMult;
@dynamic itemFleeMult;
@dynamic stopMovement;
@dynamic stopAttack;
@dynamic targetMax;
@dynamic targetSlow;

typedef struct UseItemCaptureResponse__storage_ {
  uint32_t _has_storage_[1];
  double itemCaptureMult;
  double itemFleeMult;
} UseItemCaptureResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "itemCaptureMult",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureResponse_FieldNumber_ItemCaptureMult,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UseItemCaptureResponse__storage_, itemCaptureMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "itemFleeMult",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureResponse_FieldNumber_ItemFleeMult,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UseItemCaptureResponse__storage_, itemFleeMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "stopMovement",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureResponse_FieldNumber_StopMovement,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "stopAttack",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureResponse_FieldNumber_StopAttack,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "targetMax",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureResponse_FieldNumber_TargetMax,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "targetSlow",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureResponse_FieldNumber_TargetSlow,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemCaptureResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemCaptureResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UseItemEggIncubatorResponse

@implementation UseItemEggIncubatorResponse

@dynamic result;
@dynamic hasEggIncubator, eggIncubator;

typedef struct UseItemEggIncubatorResponse__storage_ {
  uint32_t _has_storage_[1];
  UseItemEggIncubatorResponse_Result result;
  EggIncubator *eggIncubator;
} UseItemEggIncubatorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = UseItemEggIncubatorResponse_Result_EnumDescriptor,
        .number = UseItemEggIncubatorResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemEggIncubatorResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "eggIncubator",
        .dataTypeSpecific.className = GPBStringifySymbol(EggIncubator),
        .number = UseItemEggIncubatorResponse_FieldNumber_EggIncubator,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemEggIncubatorResponse__storage_, eggIncubator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemEggIncubatorResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemEggIncubatorResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemEggIncubatorResponse_Result_RawValue(UseItemEggIncubatorResponse *message) {
  GPBDescriptor *descriptor = [UseItemEggIncubatorResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemEggIncubatorResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemEggIncubatorResponse_Result_RawValue(UseItemEggIncubatorResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemEggIncubatorResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemEggIncubatorResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UseItemEggIncubatorResponse_Result

GPBEnumDescriptor *UseItemEggIncubatorResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorIncubatorNotFound\000Err"
        "orPokemonEggNotFound\000ErrorPokemonIdNotEg"
        "g\000ErrorIncubatorAlreadyInUse\000ErrorPokemo"
        "nAlreadyIncubating\000ErrorIncubatorNoUsesR"
        "emaining\000";
    static const int32_t values[] = {
        UseItemEggIncubatorResponse_Result_Unset,
        UseItemEggIncubatorResponse_Result_Success,
        UseItemEggIncubatorResponse_Result_ErrorIncubatorNotFound,
        UseItemEggIncubatorResponse_Result_ErrorPokemonEggNotFound,
        UseItemEggIncubatorResponse_Result_ErrorPokemonIdNotEgg,
        UseItemEggIncubatorResponse_Result_ErrorIncubatorAlreadyInUse,
        UseItemEggIncubatorResponse_Result_ErrorPokemonAlreadyIncubating,
        UseItemEggIncubatorResponse_Result_ErrorIncubatorNoUsesRemaining,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UseItemEggIncubatorResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UseItemEggIncubatorResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UseItemEggIncubatorResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case UseItemEggIncubatorResponse_Result_Unset:
    case UseItemEggIncubatorResponse_Result_Success:
    case UseItemEggIncubatorResponse_Result_ErrorIncubatorNotFound:
    case UseItemEggIncubatorResponse_Result_ErrorPokemonEggNotFound:
    case UseItemEggIncubatorResponse_Result_ErrorPokemonIdNotEgg:
    case UseItemEggIncubatorResponse_Result_ErrorIncubatorAlreadyInUse:
    case UseItemEggIncubatorResponse_Result_ErrorPokemonAlreadyIncubating:
    case UseItemEggIncubatorResponse_Result_ErrorIncubatorNoUsesRemaining:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UseItemEncounterResponse

@implementation UseItemEncounterResponse

@dynamic status;
@dynamic hasCaptureProbability, captureProbability;
@dynamic activeItem;

typedef struct UseItemEncounterResponse__storage_ {
  uint32_t _has_storage_[1];
  UseItemEncounterResponse_Status status;
  ItemId activeItem;
  CaptureProbability *captureProbability;
} UseItemEncounterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = UseItemEncounterResponse_Status_EnumDescriptor,
        .number = UseItemEncounterResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemEncounterResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "captureProbability",
        .dataTypeSpecific.className = GPBStringifySymbol(CaptureProbability),
        .number = UseItemEncounterResponse_FieldNumber_CaptureProbability,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemEncounterResponse__storage_, captureProbability),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activeItem",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemEncounterResponse_FieldNumber_ActiveItem,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UseItemEncounterResponse__storage_, activeItem),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemEncounterResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemEncounterResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemEncounterResponse_Status_RawValue(UseItemEncounterResponse *message) {
  GPBDescriptor *descriptor = [UseItemEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemEncounterResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemEncounterResponse_Status_RawValue(UseItemEncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemEncounterResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t UseItemEncounterResponse_ActiveItem_RawValue(UseItemEncounterResponse *message) {
  GPBDescriptor *descriptor = [UseItemEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemEncounterResponse_FieldNumber_ActiveItem];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemEncounterResponse_ActiveItem_RawValue(UseItemEncounterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemEncounterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemEncounterResponse_FieldNumber_ActiveItem];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UseItemEncounterResponse_Status

GPBEnumDescriptor *UseItemEncounterResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000AlreadyCompleted\000ActiveItemExist"
        "s\000NoItemInInventory\000InvalidItemCategory\000";
    static const int32_t values[] = {
        UseItemEncounterResponse_Status_Success,
        UseItemEncounterResponse_Status_AlreadyCompleted,
        UseItemEncounterResponse_Status_ActiveItemExists,
        UseItemEncounterResponse_Status_NoItemInInventory,
        UseItemEncounterResponse_Status_InvalidItemCategory,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UseItemEncounterResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UseItemEncounterResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UseItemEncounterResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case UseItemEncounterResponse_Status_Success:
    case UseItemEncounterResponse_Status_AlreadyCompleted:
    case UseItemEncounterResponse_Status_ActiveItemExists:
    case UseItemEncounterResponse_Status_NoItemInInventory:
    case UseItemEncounterResponse_Status_InvalidItemCategory:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UseItemGymResponse

@implementation UseItemGymResponse

@dynamic result;
@dynamic updatedGp;

typedef struct UseItemGymResponse__storage_ {
  uint32_t _has_storage_[1];
  UseItemGymResponse_Result result;
  int64_t updatedGp;
} UseItemGymResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = UseItemGymResponse_Result_EnumDescriptor,
        .number = UseItemGymResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemGymResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "updatedGp",
        .dataTypeSpecific.className = NULL,
        .number = UseItemGymResponse_FieldNumber_UpdatedGp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemGymResponse__storage_, updatedGp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemGymResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemGymResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemGymResponse_Result_RawValue(UseItemGymResponse *message) {
  GPBDescriptor *descriptor = [UseItemGymResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemGymResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemGymResponse_Result_RawValue(UseItemGymResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemGymResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemGymResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UseItemGymResponse_Result

GPBEnumDescriptor *UseItemGymResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorCannotUse\000ErrorNotInR"
        "ange\000";
    static const int32_t values[] = {
        UseItemGymResponse_Result_Unset,
        UseItemGymResponse_Result_Success,
        UseItemGymResponse_Result_ErrorCannotUse,
        UseItemGymResponse_Result_ErrorNotInRange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UseItemGymResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UseItemGymResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UseItemGymResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case UseItemGymResponse_Result_Unset:
    case UseItemGymResponse_Result_Success:
    case UseItemGymResponse_Result_ErrorCannotUse:
    case UseItemGymResponse_Result_ErrorNotInRange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UseItemPotionResponse

@implementation UseItemPotionResponse

@dynamic result;
@dynamic stamina;

typedef struct UseItemPotionResponse__storage_ {
  uint32_t _has_storage_[1];
  UseItemPotionResponse_Result result;
  int32_t stamina;
} UseItemPotionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = UseItemPotionResponse_Result_EnumDescriptor,
        .number = UseItemPotionResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemPotionResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "stamina",
        .dataTypeSpecific.className = NULL,
        .number = UseItemPotionResponse_FieldNumber_Stamina,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemPotionResponse__storage_, stamina),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemPotionResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemPotionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemPotionResponse_Result_RawValue(UseItemPotionResponse *message) {
  GPBDescriptor *descriptor = [UseItemPotionResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemPotionResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemPotionResponse_Result_RawValue(UseItemPotionResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemPotionResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemPotionResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UseItemPotionResponse_Result

GPBEnumDescriptor *UseItemPotionResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorNoPokemon\000ErrorCannot"
        "Use\000ErrorDeployedToFort\000";
    static const int32_t values[] = {
        UseItemPotionResponse_Result_Unset,
        UseItemPotionResponse_Result_Success,
        UseItemPotionResponse_Result_ErrorNoPokemon,
        UseItemPotionResponse_Result_ErrorCannotUse,
        UseItemPotionResponse_Result_ErrorDeployedToFort,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UseItemPotionResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UseItemPotionResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UseItemPotionResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case UseItemPotionResponse_Result_Unset:
    case UseItemPotionResponse_Result_Success:
    case UseItemPotionResponse_Result_ErrorNoPokemon:
    case UseItemPotionResponse_Result_ErrorCannotUse:
    case UseItemPotionResponse_Result_ErrorDeployedToFort:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UseItemReviveResponse

@implementation UseItemReviveResponse

@dynamic result;
@dynamic stamina;

typedef struct UseItemReviveResponse__storage_ {
  uint32_t _has_storage_[1];
  UseItemReviveResponse_Result result;
  int32_t stamina;
} UseItemReviveResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = UseItemReviveResponse_Result_EnumDescriptor,
        .number = UseItemReviveResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemReviveResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "stamina",
        .dataTypeSpecific.className = NULL,
        .number = UseItemReviveResponse_FieldNumber_Stamina,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemReviveResponse__storage_, stamina),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemReviveResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemReviveResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemReviveResponse_Result_RawValue(UseItemReviveResponse *message) {
  GPBDescriptor *descriptor = [UseItemReviveResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemReviveResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemReviveResponse_Result_RawValue(UseItemReviveResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemReviveResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemReviveResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UseItemReviveResponse_Result

GPBEnumDescriptor *UseItemReviveResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorNoPokemon\000ErrorCannot"
        "Use\000ErrorDeployedToFort\000";
    static const int32_t values[] = {
        UseItemReviveResponse_Result_Unset,
        UseItemReviveResponse_Result_Success,
        UseItemReviveResponse_Result_ErrorNoPokemon,
        UseItemReviveResponse_Result_ErrorCannotUse,
        UseItemReviveResponse_Result_ErrorDeployedToFort,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UseItemReviveResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UseItemReviveResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UseItemReviveResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case UseItemReviveResponse_Result_Unset:
    case UseItemReviveResponse_Result_Success:
    case UseItemReviveResponse_Result_ErrorNoPokemon:
    case UseItemReviveResponse_Result_ErrorCannotUse:
    case UseItemReviveResponse_Result_ErrorDeployedToFort:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UseItemXpBoostResponse

@implementation UseItemXpBoostResponse

@dynamic result;
@dynamic hasAppliedItems, appliedItems;

typedef struct UseItemXpBoostResponse__storage_ {
  uint32_t _has_storage_[1];
  UseItemXpBoostResponse_Result result;
  AppliedItems *appliedItems;
} UseItemXpBoostResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = UseItemXpBoostResponse_Result_EnumDescriptor,
        .number = UseItemXpBoostResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemXpBoostResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "appliedItems",
        .dataTypeSpecific.className = GPBStringifySymbol(AppliedItems),
        .number = UseItemXpBoostResponse_FieldNumber_AppliedItems,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemXpBoostResponse__storage_, appliedItems),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemXpBoostResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemXpBoostResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemXpBoostResponse_Result_RawValue(UseItemXpBoostResponse *message) {
  GPBDescriptor *descriptor = [UseItemXpBoostResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemXpBoostResponse_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemXpBoostResponse_Result_RawValue(UseItemXpBoostResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemXpBoostResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemXpBoostResponse_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UseItemXpBoostResponse_Result

GPBEnumDescriptor *UseItemXpBoostResponse_Result_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unset\000Success\000ErrorInvalidItemType\000Error"
        "XpBoostAlreadyActive\000ErrorNoItemsRemaini"
        "ng\000ErrorLocationUnset\000";
    static const int32_t values[] = {
        UseItemXpBoostResponse_Result_Unset,
        UseItemXpBoostResponse_Result_Success,
        UseItemXpBoostResponse_Result_ErrorInvalidItemType,
        UseItemXpBoostResponse_Result_ErrorXpBoostAlreadyActive,
        UseItemXpBoostResponse_Result_ErrorNoItemsRemaining,
        UseItemXpBoostResponse_Result_ErrorLocationUnset,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UseItemXpBoostResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UseItemXpBoostResponse_Result_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UseItemXpBoostResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case UseItemXpBoostResponse_Result_Unset:
    case UseItemXpBoostResponse_Result_Success:
    case UseItemXpBoostResponse_Result_ErrorInvalidItemType:
    case UseItemXpBoostResponse_Result_ErrorXpBoostAlreadyActive:
    case UseItemXpBoostResponse_Result_ErrorNoItemsRemaining:
    case UseItemXpBoostResponse_Result_ErrorLocationUnset:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - VerifyChallengeResponse

@implementation VerifyChallengeResponse

@dynamic success;

typedef struct VerifyChallengeResponse__storage_ {
  uint32_t _has_storage_[1];
} VerifyChallengeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = VerifyChallengeResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyChallengeResponse class]
                                     rootClass:[PogoprotosNetworkingResponsesRoot class]
                                          file:PogoprotosNetworkingResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyChallengeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
