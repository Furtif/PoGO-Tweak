// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: POGOProtos.Data.Battle.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "PogoprotosDataBattle.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PogoprotosDataBattleRoot

@implementation PogoprotosDataBattleRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PogoprotosDataBattleRoot_FileDescriptor

static GPBFileDescriptor *PogoprotosDataBattleRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"POGOProtos.Data.Battle"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum BattleActionType

GPBEnumDescriptor *BattleActionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ActionUnset\000ActionAttack\000ActionDodge\000Act"
        "ionSpecialAttack\000ActionSwapPokemon\000Actio"
        "nFaint\000ActionPlayerJoin\000ActionPlayerQuit"
        "\000ActionVictory\000ActionDefeat\000ActionTimedO"
        "ut\000";
    static const int32_t values[] = {
        BattleActionType_ActionUnset,
        BattleActionType_ActionAttack,
        BattleActionType_ActionDodge,
        BattleActionType_ActionSpecialAttack,
        BattleActionType_ActionSwapPokemon,
        BattleActionType_ActionFaint,
        BattleActionType_ActionPlayerJoin,
        BattleActionType_ActionPlayerQuit,
        BattleActionType_ActionVictory,
        BattleActionType_ActionDefeat,
        BattleActionType_ActionTimedOut,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BattleActionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BattleActionType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BattleActionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case BattleActionType_ActionUnset:
    case BattleActionType_ActionAttack:
    case BattleActionType_ActionDodge:
    case BattleActionType_ActionSpecialAttack:
    case BattleActionType_ActionSwapPokemon:
    case BattleActionType_ActionFaint:
    case BattleActionType_ActionPlayerJoin:
    case BattleActionType_ActionPlayerQuit:
    case BattleActionType_ActionVictory:
    case BattleActionType_ActionDefeat:
    case BattleActionType_ActionTimedOut:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BattleState

GPBEnumDescriptor *BattleState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StateUnset\000Active\000Victory\000Defeated\000Timed"
        "Out\000";
    static const int32_t values[] = {
        BattleState_StateUnset,
        BattleState_Active,
        BattleState_Victory,
        BattleState_Defeated,
        BattleState_TimedOut,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BattleState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BattleState_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BattleState_IsValidValue(int32_t value__) {
  switch (value__) {
    case BattleState_StateUnset:
    case BattleState_Active:
    case BattleState_Victory:
    case BattleState_Defeated:
    case BattleState_TimedOut:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BattleType

GPBEnumDescriptor *BattleType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "BattleTypeUnset\000BattleTypeNormal\000BattleT"
        "ypeTraining\000";
    static const int32_t values[] = {
        BattleType_BattleTypeUnset,
        BattleType_BattleTypeNormal,
        BattleType_BattleTypeTraining,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BattleType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BattleType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BattleType_IsValidValue(int32_t value__) {
  switch (value__) {
    case BattleType_BattleTypeUnset:
    case BattleType_BattleTypeNormal:
    case BattleType_BattleTypeTraining:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BattleAction

@implementation BattleAction

@dynamic type;
@dynamic actionStartMs;
@dynamic durationMs;
@dynamic energyDelta;
@dynamic attackerIndex;
@dynamic targetIndex;
@dynamic activePokemonId;
@dynamic hasPlayerJoined, playerJoined;
@dynamic hasBattleResults, battleResults;
@dynamic damageWindowsStartTimestampMs;
@dynamic damageWindowsEndTimestampMs;
@dynamic hasPlayerLeft, playerLeft;
@dynamic targetPokemonId;

typedef struct BattleAction__storage_ {
  uint32_t _has_storage_[1];
  BattleActionType type;
  int32_t durationMs;
  int32_t energyDelta;
  int32_t attackerIndex;
  int32_t targetIndex;
  BattleParticipant *playerJoined;
  BattleResults *battleResults;
  BattleParticipant *playerLeft;
  int64_t actionStartMs;
  uint64_t activePokemonId;
  int64_t damageWindowsStartTimestampMs;
  int64_t damageWindowsEndTimestampMs;
  uint64_t targetPokemonId;
} BattleAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BattleActionType_EnumDescriptor,
        .number = BattleAction_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BattleAction__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "actionStartMs",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_ActionStartMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BattleAction__storage_, actionStartMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "durationMs",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_DurationMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BattleAction__storage_, durationMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "energyDelta",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_EnergyDelta,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BattleAction__storage_, energyDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attackerIndex",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_AttackerIndex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BattleAction__storage_, attackerIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetIndex",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_TargetIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BattleAction__storage_, targetIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "activePokemonId",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_ActivePokemonId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BattleAction__storage_, activePokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "playerJoined",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleParticipant),
        .number = BattleAction_FieldNumber_PlayerJoined,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BattleAction__storage_, playerJoined),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "battleResults",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleResults),
        .number = BattleAction_FieldNumber_BattleResults,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BattleAction__storage_, battleResults),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "damageWindowsStartTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_DamageWindowsStartTimestampMs,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BattleAction__storage_, damageWindowsStartTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "damageWindowsEndTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_DamageWindowsEndTimestampMs,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BattleAction__storage_, damageWindowsEndTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerLeft",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleParticipant),
        .number = BattleAction_FieldNumber_PlayerLeft,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BattleAction__storage_, playerLeft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetPokemonId",
        .dataTypeSpecific.className = NULL,
        .number = BattleAction_FieldNumber_TargetPokemonId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BattleAction__storage_, targetPokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BattleAction class]
                                     rootClass:[PogoprotosDataBattleRoot class]
                                          file:PogoprotosDataBattleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BattleAction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BattleAction_Type_RawValue(BattleAction *message) {
  GPBDescriptor *descriptor = [BattleAction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BattleAction_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetBattleAction_Type_RawValue(BattleAction *message, int32_t value) {
  GPBDescriptor *descriptor = [BattleAction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BattleAction_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - BattleLog

@implementation BattleLog

@dynamic state;
@dynamic battleType;
@dynamic serverMs;
@dynamic battleActionsArray, battleActionsArray_Count;
@dynamic battleStartTimestampMs;
@dynamic battleEndTimestampMs;

typedef struct BattleLog__storage_ {
  uint32_t _has_storage_[1];
  BattleState state;
  BattleType battleType;
  NSMutableArray *battleActionsArray;
  int64_t serverMs;
  int64_t battleStartTimestampMs;
  int64_t battleEndTimestampMs;
} BattleLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = BattleState_EnumDescriptor,
        .number = BattleLog_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BattleLog__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "battleType",
        .dataTypeSpecific.enumDescFunc = BattleType_EnumDescriptor,
        .number = BattleLog_FieldNumber_BattleType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BattleLog__storage_, battleType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "serverMs",
        .dataTypeSpecific.className = NULL,
        .number = BattleLog_FieldNumber_ServerMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BattleLog__storage_, serverMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "battleActionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleAction),
        .number = BattleLog_FieldNumber_BattleActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BattleLog__storage_, battleActionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "battleStartTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = BattleLog_FieldNumber_BattleStartTimestampMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BattleLog__storage_, battleStartTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "battleEndTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = BattleLog_FieldNumber_BattleEndTimestampMs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BattleLog__storage_, battleEndTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BattleLog class]
                                     rootClass:[PogoprotosDataBattleRoot class]
                                          file:PogoprotosDataBattleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BattleLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BattleLog_State_RawValue(BattleLog *message) {
  GPBDescriptor *descriptor = [BattleLog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BattleLog_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetBattleLog_State_RawValue(BattleLog *message, int32_t value) {
  GPBDescriptor *descriptor = [BattleLog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BattleLog_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t BattleLog_BattleType_RawValue(BattleLog *message) {
  GPBDescriptor *descriptor = [BattleLog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BattleLog_FieldNumber_BattleType];
  return GPBGetMessageInt32Field(message, field);
}

void SetBattleLog_BattleType_RawValue(BattleLog *message, int32_t value) {
  GPBDescriptor *descriptor = [BattleLog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BattleLog_FieldNumber_BattleType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - BattleParticipant

@implementation BattleParticipant

@dynamic hasActivePokemon, activePokemon;
@dynamic hasTrainerPublicProfile, trainerPublicProfile;
@dynamic reversePokemonArray, reversePokemonArray_Count;
@dynamic defeatedPokemonArray, defeatedPokemonArray_Count;

typedef struct BattleParticipant__storage_ {
  uint32_t _has_storage_[1];
  BattlePokemonInfo *activePokemon;
  PlayerPublicProfile *trainerPublicProfile;
  NSMutableArray *reversePokemonArray;
  NSMutableArray *defeatedPokemonArray;
} BattleParticipant__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activePokemon",
        .dataTypeSpecific.className = GPBStringifySymbol(BattlePokemonInfo),
        .number = BattleParticipant_FieldNumber_ActivePokemon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BattleParticipant__storage_, activePokemon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trainerPublicProfile",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerPublicProfile),
        .number = BattleParticipant_FieldNumber_TrainerPublicProfile,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BattleParticipant__storage_, trainerPublicProfile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reversePokemonArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BattlePokemonInfo),
        .number = BattleParticipant_FieldNumber_ReversePokemonArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BattleParticipant__storage_, reversePokemonArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defeatedPokemonArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BattlePokemonInfo),
        .number = BattleParticipant_FieldNumber_DefeatedPokemonArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BattleParticipant__storage_, defeatedPokemonArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BattleParticipant class]
                                     rootClass:[PogoprotosDataBattleRoot class]
                                          file:PogoprotosDataBattleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BattleParticipant__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BattlePokemonInfo

@implementation BattlePokemonInfo

@dynamic hasPokemonData, pokemonData;
@dynamic currentHealth;
@dynamic currentEnergy;

typedef struct BattlePokemonInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t currentHealth;
  int32_t currentEnergy;
  PokemonData *pokemonData;
} BattlePokemonInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonData",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = BattlePokemonInfo_FieldNumber_PokemonData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BattlePokemonInfo__storage_, pokemonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentHealth",
        .dataTypeSpecific.className = NULL,
        .number = BattlePokemonInfo_FieldNumber_CurrentHealth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BattlePokemonInfo__storage_, currentHealth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currentEnergy",
        .dataTypeSpecific.className = NULL,
        .number = BattlePokemonInfo_FieldNumber_CurrentEnergy,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BattlePokemonInfo__storage_, currentEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BattlePokemonInfo class]
                                     rootClass:[PogoprotosDataBattleRoot class]
                                          file:PogoprotosDataBattleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BattlePokemonInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BattleResults

@implementation BattleResults

@dynamic hasGymState, gymState;
@dynamic attackersArray, attackersArray_Count;
@dynamic playerExperienceAwardedArray, playerExperienceAwardedArray_Count;
@dynamic nextDefenderPokemonId;
@dynamic gymPointsDelta;

typedef struct BattleResults__storage_ {
  uint32_t _has_storage_[1];
  int32_t gymPointsDelta;
  GymState *gymState;
  NSMutableArray *attackersArray;
  GPBInt32Array *playerExperienceAwardedArray;
  int64_t nextDefenderPokemonId;
} BattleResults__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gymState",
        .dataTypeSpecific.className = GPBStringifySymbol(GymState),
        .number = BattleResults_FieldNumber_GymState,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BattleResults__storage_, gymState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attackersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleParticipant),
        .number = BattleResults_FieldNumber_AttackersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BattleResults__storage_, attackersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerExperienceAwardedArray",
        .dataTypeSpecific.className = NULL,
        .number = BattleResults_FieldNumber_PlayerExperienceAwardedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BattleResults__storage_, playerExperienceAwardedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nextDefenderPokemonId",
        .dataTypeSpecific.className = NULL,
        .number = BattleResults_FieldNumber_NextDefenderPokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BattleResults__storage_, nextDefenderPokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gymPointsDelta",
        .dataTypeSpecific.className = NULL,
        .number = BattleResults_FieldNumber_GymPointsDelta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BattleResults__storage_, gymPointsDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BattleResults class]
                                     rootClass:[PogoprotosDataBattleRoot class]
                                          file:PogoprotosDataBattleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BattleResults__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
