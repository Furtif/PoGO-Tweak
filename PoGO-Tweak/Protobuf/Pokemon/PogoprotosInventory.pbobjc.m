// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: POGOProtos.Inventory.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "PogoprotosInventory.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PogoprotosInventoryRoot

@implementation PogoprotosInventoryRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PogoprotosInventoryRoot_FileDescriptor

static GPBFileDescriptor *PogoprotosInventoryRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"POGOProtos.Inventory"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum EggIncubatorType

GPBEnumDescriptor *EggIncubatorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "IncubatorUnset\000IncubatorDistance\000";
    static const int32_t values[] = {
        EggIncubatorType_IncubatorUnset,
        EggIncubatorType_IncubatorDistance,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EggIncubatorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EggIncubatorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EggIncubatorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EggIncubatorType_IncubatorUnset:
    case EggIncubatorType_IncubatorDistance:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum InventoryUpgradeType

GPBEnumDescriptor *InventoryUpgradeType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UpgradeUnset\000IncreaseItemStorage\000Increas"
        "ePokemonStorage\000";
    static const int32_t values[] = {
        InventoryUpgradeType_UpgradeUnset,
        InventoryUpgradeType_IncreaseItemStorage,
        InventoryUpgradeType_IncreasePokemonStorage,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(InventoryUpgradeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:InventoryUpgradeType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL InventoryUpgradeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case InventoryUpgradeType_UpgradeUnset:
    case InventoryUpgradeType_IncreaseItemStorage:
    case InventoryUpgradeType_IncreasePokemonStorage:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AppliedItem

@implementation AppliedItem

@dynamic itemId;
@dynamic itemType;
@dynamic expireMs;
@dynamic appliedMs;

typedef struct AppliedItem__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  ItemType itemType;
  int64_t expireMs;
  int64_t appliedMs;
} AppliedItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = AppliedItem_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppliedItem__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "itemType",
        .dataTypeSpecific.enumDescFunc = ItemType_EnumDescriptor,
        .number = AppliedItem_FieldNumber_ItemType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppliedItem__storage_, itemType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "expireMs",
        .dataTypeSpecific.className = NULL,
        .number = AppliedItem_FieldNumber_ExpireMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppliedItem__storage_, expireMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "appliedMs",
        .dataTypeSpecific.className = NULL,
        .number = AppliedItem_FieldNumber_AppliedMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AppliedItem__storage_, appliedMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppliedItem class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppliedItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AppliedItem_ItemId_RawValue(AppliedItem *message) {
  GPBDescriptor *descriptor = [AppliedItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AppliedItem_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetAppliedItem_ItemId_RawValue(AppliedItem *message, int32_t value) {
  GPBDescriptor *descriptor = [AppliedItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AppliedItem_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t AppliedItem_ItemType_RawValue(AppliedItem *message) {
  GPBDescriptor *descriptor = [AppliedItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AppliedItem_FieldNumber_ItemType];
  return GPBGetMessageInt32Field(message, field);
}

void SetAppliedItem_ItemType_RawValue(AppliedItem *message, int32_t value) {
  GPBDescriptor *descriptor = [AppliedItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AppliedItem_FieldNumber_ItemType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AppliedItems

@implementation AppliedItems

@dynamic itemArray, itemArray_Count;

typedef struct AppliedItems__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
} AppliedItems__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AppliedItem),
        .number = AppliedItems_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AppliedItems__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppliedItems class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppliedItems__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Candy

@implementation Candy

@dynamic familyId;
@dynamic candy;

typedef struct Candy__storage_ {
  uint32_t _has_storage_[1];
  PokemonFamilyId familyId;
  int32_t candy;
} Candy__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "familyId",
        .dataTypeSpecific.enumDescFunc = PokemonFamilyId_EnumDescriptor,
        .number = Candy_FieldNumber_FamilyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Candy__storage_, familyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "candy",
        .dataTypeSpecific.className = NULL,
        .number = Candy_FieldNumber_Candy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Candy__storage_, candy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Candy class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Candy__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Candy_FamilyId_RawValue(Candy *message) {
  GPBDescriptor *descriptor = [Candy descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Candy_FieldNumber_FamilyId];
  return GPBGetMessageInt32Field(message, field);
}

void SetCandy_FamilyId_RawValue(Candy *message, int32_t value) {
  GPBDescriptor *descriptor = [Candy descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Candy_FieldNumber_FamilyId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - EggIncubator

@implementation EggIncubator

@dynamic id_p;
@dynamic itemId;
@dynamic incubatorType;
@dynamic usesRemaining;
@dynamic pokemonId;
@dynamic startKmWalked;
@dynamic targetKmWalked;

typedef struct EggIncubator__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  EggIncubatorType incubatorType;
  int32_t usesRemaining;
  NSString *id_p;
  uint64_t pokemonId;
  double startKmWalked;
  double targetKmWalked;
} EggIncubator__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = EggIncubator_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EggIncubator__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = EggIncubator_FieldNumber_ItemId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EggIncubator__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "incubatorType",
        .dataTypeSpecific.enumDescFunc = EggIncubatorType_EnumDescriptor,
        .number = EggIncubator_FieldNumber_IncubatorType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EggIncubator__storage_, incubatorType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "usesRemaining",
        .dataTypeSpecific.className = NULL,
        .number = EggIncubator_FieldNumber_UsesRemaining,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EggIncubator__storage_, usesRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = EggIncubator_FieldNumber_PokemonId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EggIncubator__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "startKmWalked",
        .dataTypeSpecific.className = NULL,
        .number = EggIncubator_FieldNumber_StartKmWalked,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EggIncubator__storage_, startKmWalked),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "targetKmWalked",
        .dataTypeSpecific.className = NULL,
        .number = EggIncubator_FieldNumber_TargetKmWalked,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EggIncubator__storage_, targetKmWalked),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EggIncubator class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EggIncubator__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EggIncubator_ItemId_RawValue(EggIncubator *message) {
  GPBDescriptor *descriptor = [EggIncubator descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EggIncubator_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetEggIncubator_ItemId_RawValue(EggIncubator *message, int32_t value) {
  GPBDescriptor *descriptor = [EggIncubator descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EggIncubator_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t EggIncubator_IncubatorType_RawValue(EggIncubator *message) {
  GPBDescriptor *descriptor = [EggIncubator descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EggIncubator_FieldNumber_IncubatorType];
  return GPBGetMessageInt32Field(message, field);
}

void SetEggIncubator_IncubatorType_RawValue(EggIncubator *message, int32_t value) {
  GPBDescriptor *descriptor = [EggIncubator descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EggIncubator_FieldNumber_IncubatorType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - EggIncubators

@implementation EggIncubators

@dynamic eggIncubatorArray, eggIncubatorArray_Count;

typedef struct EggIncubators__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *eggIncubatorArray;
} EggIncubators__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eggIncubatorArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EggIncubator),
        .number = EggIncubators_FieldNumber_EggIncubatorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EggIncubators__storage_, eggIncubatorArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EggIncubators class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EggIncubators__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExclusiveTicketInfo

@implementation ExclusiveTicketInfo

@dynamic raidSeed;
@dynamic fortId;
@dynamic startTimeMs;
@dynamic endTimeMs;
@dynamic imageURL;
@dynamic latitude;
@dynamic longitude;
@dynamic gymName;

typedef struct ExclusiveTicketInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *fortId;
  NSString *imageURL;
  NSString *gymName;
  int64_t raidSeed;
  int64_t startTimeMs;
  int64_t endTimeMs;
  double latitude;
  double longitude;
} ExclusiveTicketInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "raidSeed",
        .dataTypeSpecific.className = NULL,
        .number = ExclusiveTicketInfo_FieldNumber_RaidSeed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExclusiveTicketInfo__storage_, raidSeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = ExclusiveTicketInfo_FieldNumber_FortId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExclusiveTicketInfo__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTimeMs",
        .dataTypeSpecific.className = NULL,
        .number = ExclusiveTicketInfo_FieldNumber_StartTimeMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExclusiveTicketInfo__storage_, startTimeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTimeMs",
        .dataTypeSpecific.className = NULL,
        .number = ExclusiveTicketInfo_FieldNumber_EndTimeMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExclusiveTicketInfo__storage_, endTimeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "imageURL",
        .dataTypeSpecific.className = NULL,
        .number = ExclusiveTicketInfo_FieldNumber_ImageURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ExclusiveTicketInfo__storage_, imageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = ExclusiveTicketInfo_FieldNumber_Latitude,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ExclusiveTicketInfo__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = ExclusiveTicketInfo_FieldNumber_Longitude,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ExclusiveTicketInfo__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gymName",
        .dataTypeSpecific.className = NULL,
        .number = ExclusiveTicketInfo_FieldNumber_GymName,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ExclusiveTicketInfo__storage_, gymName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExclusiveTicketInfo class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExclusiveTicketInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InventoryDelta

@implementation InventoryDelta

@dynamic originalTimestampMs;
@dynamic newTimestampMs;
@dynamic inventoryItemsArray, inventoryItemsArray_Count;

typedef struct InventoryDelta__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *inventoryItemsArray;
  int64_t originalTimestampMs;
  int64_t newTimestampMs;
} InventoryDelta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "originalTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = InventoryDelta_FieldNumber_OriginalTimestampMs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InventoryDelta__storage_, originalTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "newTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = InventoryDelta_FieldNumber_NewTimestampMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InventoryDelta__storage_, newTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "inventoryItemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InventoryItem),
        .number = InventoryDelta_FieldNumber_InventoryItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InventoryDelta__storage_, inventoryItemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InventoryDelta class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InventoryDelta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InventoryItem

@implementation InventoryItem

@dynamic modifiedTimestampMs;
@dynamic hasDeletedItem, deletedItem;
@dynamic hasInventoryItemData, inventoryItemData;

typedef struct InventoryItem__storage_ {
  uint32_t _has_storage_[1];
  InventoryItem_DeletedItem *deletedItem;
  InventoryItemData *inventoryItemData;
  int64_t modifiedTimestampMs;
} InventoryItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "modifiedTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = InventoryItem_FieldNumber_ModifiedTimestampMs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InventoryItem__storage_, modifiedTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deletedItem",
        .dataTypeSpecific.className = GPBStringifySymbol(InventoryItem_DeletedItem),
        .number = InventoryItem_FieldNumber_DeletedItem,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InventoryItem__storage_, deletedItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inventoryItemData",
        .dataTypeSpecific.className = GPBStringifySymbol(InventoryItemData),
        .number = InventoryItem_FieldNumber_InventoryItemData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InventoryItem__storage_, inventoryItemData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InventoryItem class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InventoryItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InventoryItem_DeletedItem

@implementation InventoryItem_DeletedItem

@dynamic pokemonId;

typedef struct InventoryItem_DeletedItem__storage_ {
  uint32_t _has_storage_[1];
  uint64_t pokemonId;
} InventoryItem_DeletedItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = InventoryItem_DeletedItem_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InventoryItem_DeletedItem__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InventoryItem_DeletedItem class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InventoryItem_DeletedItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(InventoryItem)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InventoryItemData

@implementation InventoryItemData

@dynamic hasPokemonData, pokemonData;
@dynamic hasItem, item;
@dynamic hasPokedexEntry, pokedexEntry;
@dynamic hasPlayerStats, playerStats;
@dynamic hasPlayerCurrency, playerCurrency;
@dynamic hasPlayerCamera, playerCamera;
@dynamic hasInventoryUpgrades, inventoryUpgrades;
@dynamic hasAppliedItems, appliedItems;
@dynamic hasEggIncubators, eggIncubators;
@dynamic hasCandy, candy;
@dynamic hasQuest, quest;
@dynamic hasAvatarItem, avatarItem;
@dynamic hasRaidTickets, raidTickets;

typedef struct InventoryItemData__storage_ {
  uint32_t _has_storage_[1];
  PokemonData *pokemonData;
  ItemData *item;
  PokedexEntry *pokedexEntry;
  PlayerStats *playerStats;
  PlayerCurrency *playerCurrency;
  PlayerCamera *playerCamera;
  InventoryUpgrades *inventoryUpgrades;
  AppliedItems *appliedItems;
  EggIncubators *eggIncubators;
  Candy *candy;
  Quest *quest;
  AvatarItem *avatarItem;
  RaidTickets *raidTickets;
} InventoryItemData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonData",
        .dataTypeSpecific.className = GPBStringifySymbol(PokemonData),
        .number = InventoryItemData_FieldNumber_PokemonData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, pokemonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "item",
        .dataTypeSpecific.className = GPBStringifySymbol(ItemData),
        .number = InventoryItemData_FieldNumber_Item,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, item),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pokedexEntry",
        .dataTypeSpecific.className = GPBStringifySymbol(PokedexEntry),
        .number = InventoryItemData_FieldNumber_PokedexEntry,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, pokedexEntry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerStats",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerStats),
        .number = InventoryItemData_FieldNumber_PlayerStats,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, playerStats),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerCurrency",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerCurrency),
        .number = InventoryItemData_FieldNumber_PlayerCurrency,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, playerCurrency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerCamera",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerCamera),
        .number = InventoryItemData_FieldNumber_PlayerCamera,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, playerCamera),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inventoryUpgrades",
        .dataTypeSpecific.className = GPBStringifySymbol(InventoryUpgrades),
        .number = InventoryItemData_FieldNumber_InventoryUpgrades,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, inventoryUpgrades),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appliedItems",
        .dataTypeSpecific.className = GPBStringifySymbol(AppliedItems),
        .number = InventoryItemData_FieldNumber_AppliedItems,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, appliedItems),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eggIncubators",
        .dataTypeSpecific.className = GPBStringifySymbol(EggIncubators),
        .number = InventoryItemData_FieldNumber_EggIncubators,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, eggIncubators),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "candy",
        .dataTypeSpecific.className = GPBStringifySymbol(Candy),
        .number = InventoryItemData_FieldNumber_Candy,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, candy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quest",
        .dataTypeSpecific.className = GPBStringifySymbol(Quest),
        .number = InventoryItemData_FieldNumber_Quest,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, quest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "avatarItem",
        .dataTypeSpecific.className = GPBStringifySymbol(AvatarItem),
        .number = InventoryItemData_FieldNumber_AvatarItem,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, avatarItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "raidTickets",
        .dataTypeSpecific.className = GPBStringifySymbol(RaidTickets),
        .number = InventoryItemData_FieldNumber_RaidTickets,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(InventoryItemData__storage_, raidTickets),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InventoryItemData class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InventoryItemData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InventoryKey

@implementation InventoryKey

@dynamic pokemonId;
@dynamic item;
@dynamic pokedexEntryId;
@dynamic playerStats;
@dynamic playerCurrency;
@dynamic playerCamera;
@dynamic inventoryUpgrades;
@dynamic appliedItems;
@dynamic eggIncubators;
@dynamic pokemonFamilyId;
@dynamic questType;
@dynamic avatarTemplateId;
@dynamic raidTickets;

typedef struct InventoryKey__storage_ {
  uint32_t _has_storage_[1];
  ItemId item;
  int32_t pokedexEntryId;
  PokemonFamilyId pokemonFamilyId;
  QuestType questType;
  NSString *avatarTemplateId;
  uint64_t pokemonId;
} InventoryKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InventoryKey__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "item",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = InventoryKey_FieldNumber_Item,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InventoryKey__storage_, item),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokedexEntryId",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_PokedexEntryId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InventoryKey__storage_, pokedexEntryId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerStats",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_PlayerStats,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "playerCurrency",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_PlayerCurrency,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "playerCamera",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_PlayerCamera,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "inventoryUpgrades",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_InventoryUpgrades,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "appliedItems",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_AppliedItems,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "eggIncubators",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_EggIncubators,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pokemonFamilyId",
        .dataTypeSpecific.enumDescFunc = PokemonFamilyId_EnumDescriptor,
        .number = InventoryKey_FieldNumber_PokemonFamilyId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(InventoryKey__storage_, pokemonFamilyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "questType",
        .dataTypeSpecific.enumDescFunc = QuestType_EnumDescriptor,
        .number = InventoryKey_FieldNumber_QuestType,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(InventoryKey__storage_, questType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "avatarTemplateId",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_AvatarTemplateId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(InventoryKey__storage_, avatarTemplateId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "raidTickets",
        .dataTypeSpecific.className = NULL,
        .number = InventoryKey_FieldNumber_RaidTickets,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InventoryKey class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InventoryKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t InventoryKey_Item_RawValue(InventoryKey *message) {
  GPBDescriptor *descriptor = [InventoryKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryKey_FieldNumber_Item];
  return GPBGetMessageInt32Field(message, field);
}

void SetInventoryKey_Item_RawValue(InventoryKey *message, int32_t value) {
  GPBDescriptor *descriptor = [InventoryKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryKey_FieldNumber_Item];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t InventoryKey_PokemonFamilyId_RawValue(InventoryKey *message) {
  GPBDescriptor *descriptor = [InventoryKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryKey_FieldNumber_PokemonFamilyId];
  return GPBGetMessageInt32Field(message, field);
}

void SetInventoryKey_PokemonFamilyId_RawValue(InventoryKey *message, int32_t value) {
  GPBDescriptor *descriptor = [InventoryKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryKey_FieldNumber_PokemonFamilyId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t InventoryKey_QuestType_RawValue(InventoryKey *message) {
  GPBDescriptor *descriptor = [InventoryKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryKey_FieldNumber_QuestType];
  return GPBGetMessageInt32Field(message, field);
}

void SetInventoryKey_QuestType_RawValue(InventoryKey *message, int32_t value) {
  GPBDescriptor *descriptor = [InventoryKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryKey_FieldNumber_QuestType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - InventoryUpgrade

@implementation InventoryUpgrade

@dynamic itemId;
@dynamic upgradeType;
@dynamic additionalStorage;

typedef struct InventoryUpgrade__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  InventoryUpgradeType upgradeType;
  int32_t additionalStorage;
} InventoryUpgrade__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = InventoryUpgrade_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InventoryUpgrade__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "upgradeType",
        .dataTypeSpecific.enumDescFunc = InventoryUpgradeType_EnumDescriptor,
        .number = InventoryUpgrade_FieldNumber_UpgradeType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InventoryUpgrade__storage_, upgradeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "additionalStorage",
        .dataTypeSpecific.className = NULL,
        .number = InventoryUpgrade_FieldNumber_AdditionalStorage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InventoryUpgrade__storage_, additionalStorage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InventoryUpgrade class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InventoryUpgrade__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t InventoryUpgrade_ItemId_RawValue(InventoryUpgrade *message) {
  GPBDescriptor *descriptor = [InventoryUpgrade descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryUpgrade_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetInventoryUpgrade_ItemId_RawValue(InventoryUpgrade *message, int32_t value) {
  GPBDescriptor *descriptor = [InventoryUpgrade descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryUpgrade_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t InventoryUpgrade_UpgradeType_RawValue(InventoryUpgrade *message) {
  GPBDescriptor *descriptor = [InventoryUpgrade descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryUpgrade_FieldNumber_UpgradeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetInventoryUpgrade_UpgradeType_RawValue(InventoryUpgrade *message, int32_t value) {
  GPBDescriptor *descriptor = [InventoryUpgrade descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InventoryUpgrade_FieldNumber_UpgradeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - InventoryUpgrades

@implementation InventoryUpgrades

@dynamic inventoryUpgradesArray, inventoryUpgradesArray_Count;

typedef struct InventoryUpgrades__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *inventoryUpgradesArray;
} InventoryUpgrades__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inventoryUpgradesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InventoryUpgrade),
        .number = InventoryUpgrades_FieldNumber_InventoryUpgradesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InventoryUpgrades__storage_, inventoryUpgradesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InventoryUpgrades class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InventoryUpgrades__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Loot

@implementation Loot

@dynamic lootItemArray, lootItemArray_Count;

typedef struct Loot__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *lootItemArray;
} Loot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lootItemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LootItem),
        .number = Loot_FieldNumber_LootItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Loot__storage_, lootItemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Loot class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Loot__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LootItem

@implementation LootItem

@dynamic item;
@dynamic stardust;
@dynamic pokecoin;
@dynamic pokemonCandy;
@dynamic count;

typedef struct LootItem__storage_ {
  uint32_t _has_storage_[1];
  ItemId item;
  PokemonId pokemonCandy;
  int32_t count;
} LootItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "item",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = LootItem_FieldNumber_Item,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LootItem__storage_, item),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "stardust",
        .dataTypeSpecific.className = NULL,
        .number = LootItem_FieldNumber_Stardust,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pokecoin",
        .dataTypeSpecific.className = NULL,
        .number = LootItem_FieldNumber_Pokecoin,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pokemonCandy",
        .dataTypeSpecific.enumDescFunc = PokemonId_EnumDescriptor,
        .number = LootItem_FieldNumber_PokemonCandy,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LootItem__storage_, pokemonCandy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = LootItem_FieldNumber_Count,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LootItem__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LootItem class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LootItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LootItem_Item_RawValue(LootItem *message) {
  GPBDescriptor *descriptor = [LootItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LootItem_FieldNumber_Item];
  return GPBGetMessageInt32Field(message, field);
}

void SetLootItem_Item_RawValue(LootItem *message, int32_t value) {
  GPBDescriptor *descriptor = [LootItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LootItem_FieldNumber_Item];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t LootItem_PokemonCandy_RawValue(LootItem *message) {
  GPBDescriptor *descriptor = [LootItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LootItem_FieldNumber_PokemonCandy];
  return GPBGetMessageInt32Field(message, field);
}

void SetLootItem_PokemonCandy_RawValue(LootItem *message, int32_t value) {
  GPBDescriptor *descriptor = [LootItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LootItem_FieldNumber_PokemonCandy];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RaidTicket

@implementation RaidTicket

@dynamic ticketId;
@dynamic item;
@dynamic hasExclusiveInfo, exclusiveInfo;

typedef struct RaidTicket__storage_ {
  uint32_t _has_storage_[1];
  ItemId item;
  NSString *ticketId;
  ExclusiveTicketInfo *exclusiveInfo;
} RaidTicket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ticketId",
        .dataTypeSpecific.className = NULL,
        .number = RaidTicket_FieldNumber_TicketId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RaidTicket__storage_, ticketId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "item",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = RaidTicket_FieldNumber_Item,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RaidTicket__storage_, item),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "exclusiveInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ExclusiveTicketInfo),
        .number = RaidTicket_FieldNumber_ExclusiveInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RaidTicket__storage_, exclusiveInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RaidTicket class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RaidTicket__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RaidTicket_Item_RawValue(RaidTicket *message) {
  GPBDescriptor *descriptor = [RaidTicket descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RaidTicket_FieldNumber_Item];
  return GPBGetMessageInt32Field(message, field);
}

void SetRaidTicket_Item_RawValue(RaidTicket *message, int32_t value) {
  GPBDescriptor *descriptor = [RaidTicket descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RaidTicket_FieldNumber_Item];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RaidTickets

@implementation RaidTickets

@dynamic raidTicketArray, raidTicketArray_Count;

typedef struct RaidTickets__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *raidTicketArray;
} RaidTickets__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "raidTicketArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RaidTicket),
        .number = RaidTickets_FieldNumber_RaidTicketArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RaidTickets__storage_, raidTicketArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RaidTickets class]
                                     rootClass:[PogoprotosInventoryRoot class]
                                          file:PogoprotosInventoryRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RaidTickets__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
