// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: POGOProtos.Networking.Requests.Messages.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "PogoprotosNetworkingRequestsMessages.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PogoprotosNetworkingRequestsMessagesRoot

@implementation PogoprotosNetworkingRequestsMessagesRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor

static GPBFileDescriptor *PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"POGOProtos.Networking.Requests.Messages"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AddFortModifierMessage

@implementation AddFortModifierMessage

@dynamic modifierType;
@dynamic fortId;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct AddFortModifierMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId modifierType;
  NSString *fortId;
  double playerLatitude;
  double playerLongitude;
} AddFortModifierMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "modifierType",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = AddFortModifierMessage_FieldNumber_ModifierType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFortModifierMessage__storage_, modifierType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = AddFortModifierMessage_FieldNumber_FortId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFortModifierMessage__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = AddFortModifierMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddFortModifierMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = AddFortModifierMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddFortModifierMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFortModifierMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFortModifierMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AddFortModifierMessage_ModifierType_RawValue(AddFortModifierMessage *message) {
  GPBDescriptor *descriptor = [AddFortModifierMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AddFortModifierMessage_FieldNumber_ModifierType];
  return GPBGetMessageInt32Field(message, field);
}

void SetAddFortModifierMessage_ModifierType_RawValue(AddFortModifierMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [AddFortModifierMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AddFortModifierMessage_FieldNumber_ModifierType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AttackGymMessage

@implementation AttackGymMessage

@dynamic gymId;
@dynamic battleId;
@dynamic attackActionsArray, attackActionsArray_Count;
@dynamic hasLastRetrievedAction, lastRetrievedAction;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct AttackGymMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *gymId;
  NSString *battleId;
  NSMutableArray *attackActionsArray;
  BattleAction *lastRetrievedAction;
  double playerLatitude;
  double playerLongitude;
} AttackGymMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = AttackGymMessage_FieldNumber_GymId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AttackGymMessage__storage_, gymId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "battleId",
        .dataTypeSpecific.className = NULL,
        .number = AttackGymMessage_FieldNumber_BattleId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AttackGymMessage__storage_, battleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attackActionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleAction),
        .number = AttackGymMessage_FieldNumber_AttackActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AttackGymMessage__storage_, attackActionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastRetrievedAction",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleAction),
        .number = AttackGymMessage_FieldNumber_LastRetrievedAction,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AttackGymMessage__storage_, lastRetrievedAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = AttackGymMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AttackGymMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = AttackGymMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AttackGymMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttackGymMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttackGymMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AttackRaidMessage

@implementation AttackRaidMessage

@dynamic gymId;
@dynamic battleId;
@dynamic attackerActionsArray, attackerActionsArray_Count;
@dynamic hasLastRetrievedAction, lastRetrievedAction;
@dynamic timestampMs;

typedef struct AttackRaidMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *gymId;
  NSString *battleId;
  NSMutableArray *attackerActionsArray;
  BattleAction *lastRetrievedAction;
  int64_t timestampMs;
} AttackRaidMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = AttackRaidMessage_FieldNumber_GymId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AttackRaidMessage__storage_, gymId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "battleId",
        .dataTypeSpecific.className = NULL,
        .number = AttackRaidMessage_FieldNumber_BattleId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AttackRaidMessage__storage_, battleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attackerActionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleAction),
        .number = AttackRaidMessage_FieldNumber_AttackerActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AttackRaidMessage__storage_, attackerActionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastRetrievedAction",
        .dataTypeSpecific.className = GPBStringifySymbol(BattleAction),
        .number = AttackRaidMessage_FieldNumber_LastRetrievedAction,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AttackRaidMessage__storage_, lastRetrievedAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampMs",
        .dataTypeSpecific.className = NULL,
        .number = AttackRaidMessage_FieldNumber_TimestampMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AttackRaidMessage__storage_, timestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttackRaidMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttackRaidMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CatchPokemonMessage

@implementation CatchPokemonMessage

@dynamic encounterId;
@dynamic pokeball;
@dynamic normalizedReticleSize;
@dynamic spawnPointId;
@dynamic hitPokemon;
@dynamic spinModifier;
@dynamic normalizedHitPosition;

typedef struct CatchPokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId pokeball;
  NSString *spawnPointId;
  uint64_t encounterId;
  double normalizedReticleSize;
  double spinModifier;
  double normalizedHitPosition;
} CatchPokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encounterId",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonMessage_FieldNumber_EncounterId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CatchPokemonMessage__storage_, encounterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "pokeball",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = CatchPokemonMessage_FieldNumber_Pokeball,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CatchPokemonMessage__storage_, pokeball),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "normalizedReticleSize",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonMessage_FieldNumber_NormalizedReticleSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CatchPokemonMessage__storage_, normalizedReticleSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "spawnPointId",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonMessage_FieldNumber_SpawnPointId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CatchPokemonMessage__storage_, spawnPointId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hitPokemon",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonMessage_FieldNumber_HitPokemon,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "spinModifier",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonMessage_FieldNumber_SpinModifier,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CatchPokemonMessage__storage_, spinModifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "normalizedHitPosition",
        .dataTypeSpecific.className = NULL,
        .number = CatchPokemonMessage_FieldNumber_NormalizedHitPosition,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CatchPokemonMessage__storage_, normalizedHitPosition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CatchPokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CatchPokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CatchPokemonMessage_Pokeball_RawValue(CatchPokemonMessage *message) {
  GPBDescriptor *descriptor = [CatchPokemonMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CatchPokemonMessage_FieldNumber_Pokeball];
  return GPBGetMessageInt32Field(message, field);
}

void SetCatchPokemonMessage_Pokeball_RawValue(CatchPokemonMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [CatchPokemonMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CatchPokemonMessage_FieldNumber_Pokeball];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CheckAwardedBadgesMessage

@implementation CheckAwardedBadgesMessage


typedef struct CheckAwardedBadgesMessage__storage_ {
  uint32_t _has_storage_[1];
} CheckAwardedBadgesMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckAwardedBadgesMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(CheckAwardedBadgesMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckChallengeMessage

@implementation CheckChallengeMessage

@dynamic debugRequest;

typedef struct CheckChallengeMessage__storage_ {
  uint32_t _has_storage_[1];
} CheckChallengeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "debugRequest",
        .dataTypeSpecific.className = NULL,
        .number = CheckChallengeMessage_FieldNumber_DebugRequest,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckChallengeMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckChallengeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClaimCodenameMessage

@implementation ClaimCodenameMessage

@dynamic codename;
@dynamic force;

typedef struct ClaimCodenameMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *codename;
} ClaimCodenameMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codename",
        .dataTypeSpecific.className = NULL,
        .number = ClaimCodenameMessage_FieldNumber_Codename,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClaimCodenameMessage__storage_, codename),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "force",
        .dataTypeSpecific.className = NULL,
        .number = ClaimCodenameMessage_FieldNumber_Force,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClaimCodenameMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClaimCodenameMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectDailyBonusMessage

@implementation CollectDailyBonusMessage


typedef struct CollectDailyBonusMessage__storage_ {
  uint32_t _has_storage_[1];
} CollectDailyBonusMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectDailyBonusMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(CollectDailyBonusMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectDailyDefenderBonusMessage

@implementation CollectDailyDefenderBonusMessage


typedef struct CollectDailyDefenderBonusMessage__storage_ {
  uint32_t _has_storage_[1];
} CollectDailyDefenderBonusMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectDailyDefenderBonusMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(CollectDailyDefenderBonusMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DiskEncounterMessage

@implementation DiskEncounterMessage

@dynamic encounterId;
@dynamic fortId;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct DiskEncounterMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *fortId;
  uint64_t encounterId;
  double playerLatitude;
  double playerLongitude;
} DiskEncounterMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encounterId",
        .dataTypeSpecific.className = NULL,
        .number = DiskEncounterMessage_FieldNumber_EncounterId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DiskEncounterMessage__storage_, encounterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = DiskEncounterMessage_FieldNumber_FortId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DiskEncounterMessage__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = DiskEncounterMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DiskEncounterMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = DiskEncounterMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DiskEncounterMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DiskEncounterMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DiskEncounterMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownloadItemTemplatesMessage

@implementation DownloadItemTemplatesMessage

@dynamic paginate;
@dynamic pageOffset;
@dynamic pageTimestamp;

typedef struct DownloadItemTemplatesMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageOffset;
  uint64_t pageTimestamp;
} DownloadItemTemplatesMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paginate",
        .dataTypeSpecific.className = NULL,
        .number = DownloadItemTemplatesMessage_FieldNumber_Paginate,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pageOffset",
        .dataTypeSpecific.className = NULL,
        .number = DownloadItemTemplatesMessage_FieldNumber_PageOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesMessage__storage_, pageOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = DownloadItemTemplatesMessage_FieldNumber_PageTimestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DownloadItemTemplatesMessage__storage_, pageTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadItemTemplatesMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadItemTemplatesMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownloadRemoteConfigVersionMessage

@implementation DownloadRemoteConfigVersionMessage

@dynamic platform;
@dynamic deviceManufacturer;
@dynamic deviceModel;
@dynamic locale;
@dynamic appVersion;

typedef struct DownloadRemoteConfigVersionMessage__storage_ {
  uint32_t _has_storage_[1];
  Platform platform;
  uint32_t appVersion;
  NSString *deviceManufacturer;
  NSString *deviceModel;
  NSString *locale;
} DownloadRemoteConfigVersionMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "platform",
        .dataTypeSpecific.enumDescFunc = Platform_EnumDescriptor,
        .number = DownloadRemoteConfigVersionMessage_FieldNumber_Platform,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownloadRemoteConfigVersionMessage__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceManufacturer",
        .dataTypeSpecific.className = NULL,
        .number = DownloadRemoteConfigVersionMessage_FieldNumber_DeviceManufacturer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DownloadRemoteConfigVersionMessage__storage_, deviceManufacturer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = DownloadRemoteConfigVersionMessage_FieldNumber_DeviceModel,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownloadRemoteConfigVersionMessage__storage_, deviceModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = DownloadRemoteConfigVersionMessage_FieldNumber_Locale,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DownloadRemoteConfigVersionMessage__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = DownloadRemoteConfigVersionMessage_FieldNumber_AppVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DownloadRemoteConfigVersionMessage__storage_, appVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadRemoteConfigVersionMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadRemoteConfigVersionMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DownloadRemoteConfigVersionMessage_Platform_RawValue(DownloadRemoteConfigVersionMessage *message) {
  GPBDescriptor *descriptor = [DownloadRemoteConfigVersionMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownloadRemoteConfigVersionMessage_FieldNumber_Platform];
  return GPBGetMessageInt32Field(message, field);
}

void SetDownloadRemoteConfigVersionMessage_Platform_RawValue(DownloadRemoteConfigVersionMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [DownloadRemoteConfigVersionMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownloadRemoteConfigVersionMessage_FieldNumber_Platform];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - DownloadSettingsMessage

@implementation DownloadSettingsMessage

@dynamic hash_p;

typedef struct DownloadSettingsMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *hash_p;
} DownloadSettingsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = DownloadSettingsMessage_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownloadSettingsMessage__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadSettingsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadSettingsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EchoMessage

@implementation EchoMessage


typedef struct EchoMessage__storage_ {
  uint32_t _has_storage_[1];
} EchoMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EchoMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(EchoMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncounterMessage

@implementation EncounterMessage

@dynamic encounterId;
@dynamic spawnPointId;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct EncounterMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *spawnPointId;
  uint64_t encounterId;
  double playerLatitude;
  double playerLongitude;
} EncounterMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encounterId",
        .dataTypeSpecific.className = NULL,
        .number = EncounterMessage_FieldNumber_EncounterId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncounterMessage__storage_, encounterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "spawnPointId",
        .dataTypeSpecific.className = NULL,
        .number = EncounterMessage_FieldNumber_SpawnPointId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncounterMessage__storage_, spawnPointId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = EncounterMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EncounterMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = EncounterMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EncounterMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncounterMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncounterMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncounterTutorialCompleteMessage

@implementation EncounterTutorialCompleteMessage

@dynamic pokemonId;

typedef struct EncounterTutorialCompleteMessage__storage_ {
  uint32_t _has_storage_[1];
  PokemonId pokemonId;
} EncounterTutorialCompleteMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.enumDescFunc = PokemonId_EnumDescriptor,
        .number = EncounterTutorialCompleteMessage_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncounterTutorialCompleteMessage__storage_, pokemonId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncounterTutorialCompleteMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncounterTutorialCompleteMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EncounterTutorialCompleteMessage_PokemonId_RawValue(EncounterTutorialCompleteMessage *message) {
  GPBDescriptor *descriptor = [EncounterTutorialCompleteMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterTutorialCompleteMessage_FieldNumber_PokemonId];
  return GPBGetMessageInt32Field(message, field);
}

void SetEncounterTutorialCompleteMessage_PokemonId_RawValue(EncounterTutorialCompleteMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [EncounterTutorialCompleteMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncounterTutorialCompleteMessage_FieldNumber_PokemonId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - EquipBadgeMessage

@implementation EquipBadgeMessage

@dynamic badgeType;

typedef struct EquipBadgeMessage__storage_ {
  uint32_t _has_storage_[1];
  BadgeType badgeType;
} EquipBadgeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "badgeType",
        .dataTypeSpecific.enumDescFunc = BadgeType_EnumDescriptor,
        .number = EquipBadgeMessage_FieldNumber_BadgeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EquipBadgeMessage__storage_, badgeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EquipBadgeMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EquipBadgeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EquipBadgeMessage_BadgeType_RawValue(EquipBadgeMessage *message) {
  GPBDescriptor *descriptor = [EquipBadgeMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EquipBadgeMessage_FieldNumber_BadgeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetEquipBadgeMessage_BadgeType_RawValue(EquipBadgeMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [EquipBadgeMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EquipBadgeMessage_FieldNumber_BadgeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - EvolvePokemonMessage

@implementation EvolvePokemonMessage

@dynamic pokemonId;
@dynamic evolutionItemRequirement;

typedef struct EvolvePokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId evolutionItemRequirement;
  uint64_t pokemonId;
} EvolvePokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = EvolvePokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EvolvePokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "evolutionItemRequirement",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = EvolvePokemonMessage_FieldNumber_EvolutionItemRequirement,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EvolvePokemonMessage__storage_, evolutionItemRequirement),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EvolvePokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EvolvePokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EvolvePokemonMessage_EvolutionItemRequirement_RawValue(EvolvePokemonMessage *message) {
  GPBDescriptor *descriptor = [EvolvePokemonMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EvolvePokemonMessage_FieldNumber_EvolutionItemRequirement];
  return GPBGetMessageInt32Field(message, field);
}

void SetEvolvePokemonMessage_EvolutionItemRequirement_RawValue(EvolvePokemonMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [EvolvePokemonMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EvolvePokemonMessage_FieldNumber_EvolutionItemRequirement];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - FortDeployPokemonMessage

@implementation FortDeployPokemonMessage

@dynamic fortId;
@dynamic pokemonId;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct FortDeployPokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *fortId;
  uint64_t pokemonId;
  double playerLatitude;
  double playerLongitude;
} FortDeployPokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = FortDeployPokemonMessage_FieldNumber_FortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FortDeployPokemonMessage__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = FortDeployPokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FortDeployPokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = FortDeployPokemonMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FortDeployPokemonMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = FortDeployPokemonMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FortDeployPokemonMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FortDeployPokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FortDeployPokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FortDetailsMessage

@implementation FortDetailsMessage

@dynamic fortId;
@dynamic latitude;
@dynamic longitude;

typedef struct FortDetailsMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *fortId;
  double latitude;
  double longitude;
} FortDetailsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsMessage_FieldNumber_FortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FortDetailsMessage__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsMessage_FieldNumber_Latitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FortDetailsMessage__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = FortDetailsMessage_FieldNumber_Longitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FortDetailsMessage__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FortDetailsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FortDetailsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FortRecallPokemonMessage

@implementation FortRecallPokemonMessage

@dynamic fortId;
@dynamic pokemonId;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct FortRecallPokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *fortId;
  uint64_t pokemonId;
  double playerLatitude;
  double playerLongitude;
} FortRecallPokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = FortRecallPokemonMessage_FieldNumber_FortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FortRecallPokemonMessage__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = FortRecallPokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FortRecallPokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = FortRecallPokemonMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FortRecallPokemonMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = FortRecallPokemonMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FortRecallPokemonMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FortRecallPokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FortRecallPokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FortSearchMessage

@implementation FortSearchMessage

@dynamic fortId;
@dynamic playerLatitude;
@dynamic playerLongitude;
@dynamic fortLatitude;
@dynamic fortLongitude;

typedef struct FortSearchMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *fortId;
  double playerLatitude;
  double playerLongitude;
  double fortLatitude;
  double fortLongitude;
} FortSearchMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchMessage_FieldNumber_FortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FortSearchMessage__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FortSearchMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FortSearchMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fortLatitude",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchMessage_FieldNumber_FortLatitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FortSearchMessage__storage_, fortLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fortLongitude",
        .dataTypeSpecific.className = NULL,
        .number = FortSearchMessage_FieldNumber_FortLongitude,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FortSearchMessage__storage_, fortLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FortSearchMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FortSearchMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAssetDigestMessage

@implementation GetAssetDigestMessage

@dynamic platform;
@dynamic deviceManufacturer;
@dynamic deviceModel;
@dynamic locale;
@dynamic appVersion;
@dynamic paginate;
@dynamic pageOffset;
@dynamic pageTimestamp;

typedef struct GetAssetDigestMessage__storage_ {
  uint32_t _has_storage_[1];
  Platform platform;
  uint32_t appVersion;
  int32_t pageOffset;
  NSString *deviceManufacturer;
  NSString *deviceModel;
  NSString *locale;
  uint64_t pageTimestamp;
} GetAssetDigestMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "platform",
        .dataTypeSpecific.enumDescFunc = Platform_EnumDescriptor,
        .number = GetAssetDigestMessage_FieldNumber_Platform,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAssetDigestMessage__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceManufacturer",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestMessage_FieldNumber_DeviceManufacturer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAssetDigestMessage__storage_, deviceManufacturer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestMessage_FieldNumber_DeviceModel,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetAssetDigestMessage__storage_, deviceModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestMessage_FieldNumber_Locale,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetAssetDigestMessage__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestMessage_FieldNumber_AppVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetAssetDigestMessage__storage_, appVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "paginate",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestMessage_FieldNumber_Paginate,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pageOffset",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestMessage_FieldNumber_PageOffset,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetAssetDigestMessage__storage_, pageOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = GetAssetDigestMessage_FieldNumber_PageTimestamp,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GetAssetDigestMessage__storage_, pageTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAssetDigestMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAssetDigestMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetAssetDigestMessage_Platform_RawValue(GetAssetDigestMessage *message) {
  GPBDescriptor *descriptor = [GetAssetDigestMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetAssetDigestMessage_FieldNumber_Platform];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetAssetDigestMessage_Platform_RawValue(GetAssetDigestMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [GetAssetDigestMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetAssetDigestMessage_FieldNumber_Platform];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GetBuddyWalkedMessage

@implementation GetBuddyWalkedMessage


typedef struct GetBuddyWalkedMessage__storage_ {
  uint32_t _has_storage_[1];
} GetBuddyWalkedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBuddyWalkedMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetBuddyWalkedMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDownloadUrlsMessage

@implementation GetDownloadUrlsMessage

@dynamic assetIdArray, assetIdArray_Count;

typedef struct GetDownloadUrlsMessage__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *assetIdArray;
} GetDownloadUrlsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetIdArray",
        .dataTypeSpecific.className = NULL,
        .number = GetDownloadUrlsMessage_FieldNumber_AssetIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDownloadUrlsMessage__storage_, assetIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDownloadUrlsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDownloadUrlsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetGymBadgeDetailsMessage

@implementation GetGymBadgeDetailsMessage

@dynamic fortId;
@dynamic latitude;
@dynamic longitude;

typedef struct GetGymBadgeDetailsMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *fortId;
  double latitude;
  double longitude;
} GetGymBadgeDetailsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = GetGymBadgeDetailsMessage_FieldNumber_FortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetGymBadgeDetailsMessage__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = GetGymBadgeDetailsMessage_FieldNumber_Latitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetGymBadgeDetailsMessage__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = GetGymBadgeDetailsMessage_FieldNumber_Longitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetGymBadgeDetailsMessage__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetGymBadgeDetailsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetGymBadgeDetailsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetGymDetailsMessage

@implementation GetGymDetailsMessage

@dynamic gymId;
@dynamic playerLatitude;
@dynamic playerLongitude;
@dynamic gymLatitude;
@dynamic gymLongitude;
@dynamic clientVersion;

typedef struct GetGymDetailsMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *gymId;
  NSString *clientVersion;
  double playerLatitude;
  double playerLongitude;
  double gymLatitude;
  double gymLongitude;
} GetGymDetailsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsMessage_FieldNumber_GymId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetGymDetailsMessage__storage_, gymId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetGymDetailsMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetGymDetailsMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gymLatitude",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsMessage_FieldNumber_GymLatitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetGymDetailsMessage__storage_, gymLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gymLongitude",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsMessage_FieldNumber_GymLongitude,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetGymDetailsMessage__storage_, gymLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = GetGymDetailsMessage_FieldNumber_ClientVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetGymDetailsMessage__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetGymDetailsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetGymDetailsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetHatchedEggsMessage

@implementation GetHatchedEggsMessage


typedef struct GetHatchedEggsMessage__storage_ {
  uint32_t _has_storage_[1];
} GetHatchedEggsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetHatchedEggsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetHatchedEggsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInboxMessage

@implementation GetInboxMessage

@dynamic isHistory;
@dynamic isReverse;
@dynamic notBeforeMs;

typedef struct GetInboxMessage__storage_ {
  uint32_t _has_storage_[1];
  int64_t notBeforeMs;
} GetInboxMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isHistory",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxMessage_FieldNumber_IsHistory,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isReverse",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxMessage_FieldNumber_IsReverse,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "notBeforeMs",
        .dataTypeSpecific.className = NULL,
        .number = GetInboxMessage_FieldNumber_NotBeforeMs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetInboxMessage__storage_, notBeforeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInboxMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInboxMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIncensePokemonMessage

@implementation GetIncensePokemonMessage

@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct GetIncensePokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  double playerLatitude;
  double playerLongitude;
} GetIncensePokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = GetIncensePokemonMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIncensePokemonMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = GetIncensePokemonMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIncensePokemonMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIncensePokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIncensePokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInventoryMessage

@implementation GetInventoryMessage

@dynamic lastTimestampMs;
@dynamic itemBeenSeen;

typedef struct GetInventoryMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t itemBeenSeen;
  int64_t lastTimestampMs;
} GetInventoryMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastTimestampMs",
        .dataTypeSpecific.className = NULL,
        .number = GetInventoryMessage_FieldNumber_LastTimestampMs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetInventoryMessage__storage_, lastTimestampMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "itemBeenSeen",
        .dataTypeSpecific.className = NULL,
        .number = GetInventoryMessage_FieldNumber_ItemBeenSeen,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetInventoryMessage__storage_, itemBeenSeen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInventoryMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInventoryMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMapObjectsMessage

@implementation GetMapObjectsMessage

@dynamic cellIdArray, cellIdArray_Count;
@dynamic sinceTimestampMsArray, sinceTimestampMsArray_Count;
@dynamic latitude;
@dynamic longitude;

typedef struct GetMapObjectsMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *cellIdArray;
  GPBInt64Array *sinceTimestampMsArray;
  double latitude;
  double longitude;
} GetMapObjectsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cellIdArray",
        .dataTypeSpecific.className = NULL,
        .number = GetMapObjectsMessage_FieldNumber_CellIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMapObjectsMessage__storage_, cellIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sinceTimestampMsArray",
        .dataTypeSpecific.className = NULL,
        .number = GetMapObjectsMessage_FieldNumber_SinceTimestampMsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMapObjectsMessage__storage_, sinceTimestampMsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = GetMapObjectsMessage_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMapObjectsMessage__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = GetMapObjectsMessage_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetMapObjectsMessage__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMapObjectsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMapObjectsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPlayerMessage

@implementation GetPlayerMessage

@dynamic hasPlayerLocale, playerLocale;

typedef struct GetPlayerMessage__storage_ {
  uint32_t _has_storage_[1];
  GetPlayerMessage_PlayerLocale *playerLocale;
} GetPlayerMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerLocale",
        .dataTypeSpecific.className = GPBStringifySymbol(GetPlayerMessage_PlayerLocale),
        .number = GetPlayerMessage_FieldNumber_PlayerLocale,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPlayerMessage__storage_, playerLocale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPlayerMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPlayerMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPlayerMessage_PlayerLocale

@implementation GetPlayerMessage_PlayerLocale

@dynamic country;
@dynamic language;
@dynamic timezone;

typedef struct GetPlayerMessage_PlayerLocale__storage_ {
  uint32_t _has_storage_[1];
  NSString *country;
  NSString *language;
  NSString *timezone;
} GetPlayerMessage_PlayerLocale__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = GetPlayerMessage_PlayerLocale_FieldNumber_Country,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPlayerMessage_PlayerLocale__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = GetPlayerMessage_PlayerLocale_FieldNumber_Language,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPlayerMessage_PlayerLocale__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timezone",
        .dataTypeSpecific.className = NULL,
        .number = GetPlayerMessage_PlayerLocale_FieldNumber_Timezone,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetPlayerMessage_PlayerLocale__storage_, timezone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPlayerMessage_PlayerLocale class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPlayerMessage_PlayerLocale__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GetPlayerMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPlayerProfileMessage

@implementation GetPlayerProfileMessage

@dynamic playerName;

typedef struct GetPlayerProfileMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *playerName;
} GetPlayerProfileMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerName",
        .dataTypeSpecific.className = NULL,
        .number = GetPlayerProfileMessage_FieldNumber_PlayerName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPlayerProfileMessage__storage_, playerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPlayerProfileMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPlayerProfileMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRaidDetailsMessage

@implementation GetRaidDetailsMessage

@dynamic raidSeed;
@dynamic gymId;
@dynamic lobbyIdArray, lobbyIdArray_Count;
@dynamic playerLatDegrees;
@dynamic playerLngDegrees;

typedef struct GetRaidDetailsMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *gymId;
  GPBInt32Array *lobbyIdArray;
  int64_t raidSeed;
  double playerLatDegrees;
  double playerLngDegrees;
} GetRaidDetailsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "raidSeed",
        .dataTypeSpecific.className = NULL,
        .number = GetRaidDetailsMessage_FieldNumber_RaidSeed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRaidDetailsMessage__storage_, raidSeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = GetRaidDetailsMessage_FieldNumber_GymId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetRaidDetailsMessage__storage_, gymId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lobbyIdArray",
        .dataTypeSpecific.className = NULL,
        .number = GetRaidDetailsMessage_FieldNumber_LobbyIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetRaidDetailsMessage__storage_, lobbyIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerLatDegrees",
        .dataTypeSpecific.className = NULL,
        .number = GetRaidDetailsMessage_FieldNumber_PlayerLatDegrees,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetRaidDetailsMessage__storage_, playerLatDegrees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLngDegrees",
        .dataTypeSpecific.className = NULL,
        .number = GetRaidDetailsMessage_FieldNumber_PlayerLngDegrees,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetRaidDetailsMessage__storage_, playerLngDegrees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRaidDetailsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRaidDetailsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GymDeployMessage

@implementation GymDeployMessage

@dynamic fortId;
@dynamic pokemonId;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct GymDeployMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *fortId;
  uint64_t pokemonId;
  double playerLatitude;
  double playerLongitude;
} GymDeployMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fortId",
        .dataTypeSpecific.className = NULL,
        .number = GymDeployMessage_FieldNumber_FortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GymDeployMessage__storage_, fortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = GymDeployMessage_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GymDeployMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = GymDeployMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GymDeployMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = GymDeployMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GymDeployMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GymDeployMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GymDeployMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GymFeedPokemonMessage

@implementation GymFeedPokemonMessage

@dynamic item;
@dynamic startingQuantity;
@dynamic gymId;
@dynamic pokemonId;
@dynamic playerLatDegrees;
@dynamic playerLngDegrees;

typedef struct GymFeedPokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId item;
  int32_t startingQuantity;
  NSString *gymId;
  uint64_t pokemonId;
  double playerLatDegrees;
  double playerLngDegrees;
} GymFeedPokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "item",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = GymFeedPokemonMessage_FieldNumber_Item,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GymFeedPokemonMessage__storage_, item),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startingQuantity",
        .dataTypeSpecific.className = NULL,
        .number = GymFeedPokemonMessage_FieldNumber_StartingQuantity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GymFeedPokemonMessage__storage_, startingQuantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = GymFeedPokemonMessage_FieldNumber_GymId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GymFeedPokemonMessage__storage_, gymId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = GymFeedPokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GymFeedPokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "playerLatDegrees",
        .dataTypeSpecific.className = NULL,
        .number = GymFeedPokemonMessage_FieldNumber_PlayerLatDegrees,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GymFeedPokemonMessage__storage_, playerLatDegrees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLngDegrees",
        .dataTypeSpecific.className = NULL,
        .number = GymFeedPokemonMessage_FieldNumber_PlayerLngDegrees,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GymFeedPokemonMessage__storage_, playerLngDegrees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GymFeedPokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GymFeedPokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GymFeedPokemonMessage_Item_RawValue(GymFeedPokemonMessage *message) {
  GPBDescriptor *descriptor = [GymFeedPokemonMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GymFeedPokemonMessage_FieldNumber_Item];
  return GPBGetMessageInt32Field(message, field);
}

void SetGymFeedPokemonMessage_Item_RawValue(GymFeedPokemonMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [GymFeedPokemonMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GymFeedPokemonMessage_FieldNumber_Item];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GymGetInfoMessage

@implementation GymGetInfoMessage

@dynamic gymId;
@dynamic playerLatDegrees;
@dynamic playerLngDegrees;
@dynamic gymLatDegrees;
@dynamic gymLngDegrees;

typedef struct GymGetInfoMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *gymId;
  double playerLatDegrees;
  double playerLngDegrees;
  double gymLatDegrees;
  double gymLngDegrees;
} GymGetInfoMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = GymGetInfoMessage_FieldNumber_GymId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GymGetInfoMessage__storage_, gymId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerLatDegrees",
        .dataTypeSpecific.className = NULL,
        .number = GymGetInfoMessage_FieldNumber_PlayerLatDegrees,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GymGetInfoMessage__storage_, playerLatDegrees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLngDegrees",
        .dataTypeSpecific.className = NULL,
        .number = GymGetInfoMessage_FieldNumber_PlayerLngDegrees,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GymGetInfoMessage__storage_, playerLngDegrees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gymLatDegrees",
        .dataTypeSpecific.className = NULL,
        .number = GymGetInfoMessage_FieldNumber_GymLatDegrees,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GymGetInfoMessage__storage_, gymLatDegrees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gymLngDegrees",
        .dataTypeSpecific.className = NULL,
        .number = GymGetInfoMessage_FieldNumber_GymLngDegrees,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GymGetInfoMessage__storage_, gymLngDegrees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GymGetInfoMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GymGetInfoMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IncenseEncounterMessage

@implementation IncenseEncounterMessage

@dynamic encounterId;
@dynamic encounterLocation;

typedef struct IncenseEncounterMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *encounterLocation;
  uint64_t encounterId;
} IncenseEncounterMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encounterId",
        .dataTypeSpecific.className = NULL,
        .number = IncenseEncounterMessage_FieldNumber_EncounterId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IncenseEncounterMessage__storage_, encounterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "encounterLocation",
        .dataTypeSpecific.className = NULL,
        .number = IncenseEncounterMessage_FieldNumber_EncounterLocation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IncenseEncounterMessage__storage_, encounterLocation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IncenseEncounterMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncenseEncounterMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LevelUpRewardsMessage

@implementation LevelUpRewardsMessage

@dynamic level;

typedef struct LevelUpRewardsMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
} LevelUpRewardsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = LevelUpRewardsMessage_FieldNumber_Level,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LevelUpRewardsMessage__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LevelUpRewardsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LevelUpRewardsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListAvatarCustomizationsMessage

@implementation ListAvatarCustomizationsMessage

@dynamic avatarType;
@dynamic slotArray, slotArray_Count;
@dynamic filtersArray, filtersArray_Count;
@dynamic start;
@dynamic limit;

typedef struct ListAvatarCustomizationsMessage__storage_ {
  uint32_t _has_storage_[1];
  PlayerAvatarType avatarType;
  int32_t start;
  int32_t limit;
  GPBEnumArray *slotArray;
  GPBEnumArray *filtersArray;
} ListAvatarCustomizationsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatarType",
        .dataTypeSpecific.enumDescFunc = PlayerAvatarType_EnumDescriptor,
        .number = ListAvatarCustomizationsMessage_FieldNumber_AvatarType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListAvatarCustomizationsMessage__storage_, avatarType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "slotArray",
        .dataTypeSpecific.enumDescFunc = Slot_EnumDescriptor,
        .number = ListAvatarCustomizationsMessage_FieldNumber_SlotArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListAvatarCustomizationsMessage__storage_, slotArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "filtersArray",
        .dataTypeSpecific.enumDescFunc = Filter_EnumDescriptor,
        .number = ListAvatarCustomizationsMessage_FieldNumber_FiltersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListAvatarCustomizationsMessage__storage_, filtersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = ListAvatarCustomizationsMessage_FieldNumber_Start,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ListAvatarCustomizationsMessage__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = ListAvatarCustomizationsMessage_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ListAvatarCustomizationsMessage__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListAvatarCustomizationsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListAvatarCustomizationsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ListAvatarCustomizationsMessage_AvatarType_RawValue(ListAvatarCustomizationsMessage *message) {
  GPBDescriptor *descriptor = [ListAvatarCustomizationsMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ListAvatarCustomizationsMessage_FieldNumber_AvatarType];
  return GPBGetMessageInt32Field(message, field);
}

void SetListAvatarCustomizationsMessage_AvatarType_RawValue(ListAvatarCustomizationsMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [ListAvatarCustomizationsMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ListAvatarCustomizationsMessage_FieldNumber_AvatarType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ListGymBadgesMessage

@implementation ListGymBadgesMessage


typedef struct ListGymBadgesMessage__storage_ {
  uint32_t _has_storage_[1];
} ListGymBadgesMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListGymBadgesMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ListGymBadgesMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MarkTutorialCompleteMessage

@implementation MarkTutorialCompleteMessage

@dynamic tutorialsCompletedArray, tutorialsCompletedArray_Count;
@dynamic sendMarketingEmails;
@dynamic sendPushNotifications;

typedef struct MarkTutorialCompleteMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *tutorialsCompletedArray;
} MarkTutorialCompleteMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tutorialsCompletedArray",
        .dataTypeSpecific.enumDescFunc = TutorialState_EnumDescriptor,
        .number = MarkTutorialCompleteMessage_FieldNumber_TutorialsCompletedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MarkTutorialCompleteMessage__storage_, tutorialsCompletedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sendMarketingEmails",
        .dataTypeSpecific.className = NULL,
        .number = MarkTutorialCompleteMessage_FieldNumber_SendMarketingEmails,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendPushNotifications",
        .dataTypeSpecific.className = NULL,
        .number = MarkTutorialCompleteMessage_FieldNumber_SendPushNotifications,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MarkTutorialCompleteMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarkTutorialCompleteMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NicknamePokemonMessage

@implementation NicknamePokemonMessage

@dynamic pokemonId;
@dynamic nickname;

typedef struct NicknamePokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickname;
  uint64_t pokemonId;
} NicknamePokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = NicknamePokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NicknamePokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = NicknamePokemonMessage_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NicknamePokemonMessage__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NicknamePokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NicknamePokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterPushNotificationMessage

@implementation RegisterPushNotificationMessage

@dynamic hasApnToken, apnToken;
@dynamic hasGcmToken, gcmToken;

typedef struct RegisterPushNotificationMessage__storage_ {
  uint32_t _has_storage_[1];
  RegisterPushNotificationMessage_ApnToken *apnToken;
  RegisterPushNotificationMessage_GcmToken *gcmToken;
} RegisterPushNotificationMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "apnToken",
        .dataTypeSpecific.className = GPBStringifySymbol(RegisterPushNotificationMessage_ApnToken),
        .number = RegisterPushNotificationMessage_FieldNumber_ApnToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterPushNotificationMessage__storage_, apnToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gcmToken",
        .dataTypeSpecific.className = GPBStringifySymbol(RegisterPushNotificationMessage_GcmToken),
        .number = RegisterPushNotificationMessage_FieldNumber_GcmToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterPushNotificationMessage__storage_, gcmToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterPushNotificationMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterPushNotificationMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterPushNotificationMessage_ApnToken

@implementation RegisterPushNotificationMessage_ApnToken

@dynamic registrationId;
@dynamic bundleIdentifier;
@dynamic payloadByteSize;

typedef struct RegisterPushNotificationMessage_ApnToken__storage_ {
  uint32_t _has_storage_[1];
  int32_t payloadByteSize;
  NSString *registrationId;
  NSString *bundleIdentifier;
} RegisterPushNotificationMessage_ApnToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "registrationId",
        .dataTypeSpecific.className = NULL,
        .number = RegisterPushNotificationMessage_ApnToken_FieldNumber_RegistrationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterPushNotificationMessage_ApnToken__storage_, registrationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = RegisterPushNotificationMessage_ApnToken_FieldNumber_BundleIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterPushNotificationMessage_ApnToken__storage_, bundleIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payloadByteSize",
        .dataTypeSpecific.className = NULL,
        .number = RegisterPushNotificationMessage_ApnToken_FieldNumber_PayloadByteSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RegisterPushNotificationMessage_ApnToken__storage_, payloadByteSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterPushNotificationMessage_ApnToken class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterPushNotificationMessage_ApnToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RegisterPushNotificationMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterPushNotificationMessage_GcmToken

@implementation RegisterPushNotificationMessage_GcmToken

@dynamic registrationId;

typedef struct RegisterPushNotificationMessage_GcmToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *registrationId;
} RegisterPushNotificationMessage_GcmToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "registrationId",
        .dataTypeSpecific.className = NULL,
        .number = RegisterPushNotificationMessage_GcmToken_FieldNumber_RegistrationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterPushNotificationMessage_GcmToken__storage_, registrationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterPushNotificationMessage_GcmToken class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterPushNotificationMessage_GcmToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RegisterPushNotificationMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateNotificationStatusMessage

@implementation UpdateNotificationStatusMessage

@dynamic notificationIdsArray, notificationIdsArray_Count;
@dynamic createTimestampMsArray, createTimestampMsArray_Count;
@dynamic state;

typedef struct UpdateNotificationStatusMessage__storage_ {
  uint32_t _has_storage_[1];
  UpdateNotificationStatusMessage_NotificationState state;
  NSMutableArray *notificationIdsArray;
  GPBInt64Array *createTimestampMsArray;
} UpdateNotificationStatusMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = UpdateNotificationStatusMessage_FieldNumber_NotificationIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateNotificationStatusMessage__storage_, notificationIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTimestampMsArray",
        .dataTypeSpecific.className = NULL,
        .number = UpdateNotificationStatusMessage_FieldNumber_CreateTimestampMsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateNotificationStatusMessage__storage_, createTimestampMsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = UpdateNotificationStatusMessage_NotificationState_EnumDescriptor,
        .number = UpdateNotificationStatusMessage_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateNotificationStatusMessage__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateNotificationStatusMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateNotificationStatusMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UpdateNotificationStatusMessage_State_RawValue(UpdateNotificationStatusMessage *message) {
  GPBDescriptor *descriptor = [UpdateNotificationStatusMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdateNotificationStatusMessage_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetUpdateNotificationStatusMessage_State_RawValue(UpdateNotificationStatusMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UpdateNotificationStatusMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdateNotificationStatusMessage_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UpdateNotificationStatusMessage_NotificationState

GPBEnumDescriptor *UpdateNotificationStatusMessage_NotificationState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnsetState\000Viewed\000";
    static const int32_t values[] = {
        UpdateNotificationStatusMessage_NotificationState_UnsetState,
        UpdateNotificationStatusMessage_NotificationState_Viewed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UpdateNotificationStatusMessage_NotificationState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UpdateNotificationStatusMessage_NotificationState_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UpdateNotificationStatusMessage_NotificationState_IsValidValue(int32_t value__) {
  switch (value__) {
    case UpdateNotificationStatusMessage_NotificationState_UnsetState:
    case UpdateNotificationStatusMessage_NotificationState_Viewed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - OptOutPushNotificationCategoryMessage

@implementation OptOutPushNotificationCategoryMessage

@dynamic categoriesArray, categoriesArray_Count;

typedef struct OptOutPushNotificationCategoryMessage__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *categoriesArray;
} OptOutPushNotificationCategoryMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categoriesArray",
        .dataTypeSpecific.className = NULL,
        .number = OptOutPushNotificationCategoryMessage_FieldNumber_CategoriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OptOutPushNotificationCategoryMessage__storage_, categoriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OptOutPushNotificationCategoryMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OptOutPushNotificationCategoryMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushNotificationRegistryMessage

@implementation PushNotificationRegistryMessage

@dynamic hasApnToken, apnToken;
@dynamic hasGcmToken, gcmToken;

typedef struct PushNotificationRegistryMessage__storage_ {
  uint32_t _has_storage_[1];
  PushNotificationRegistryMessage_ApnToken *apnToken;
  PushNotificationRegistryMessage_GcmToken *gcmToken;
} PushNotificationRegistryMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "apnToken",
        .dataTypeSpecific.className = GPBStringifySymbol(PushNotificationRegistryMessage_ApnToken),
        .number = PushNotificationRegistryMessage_FieldNumber_ApnToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushNotificationRegistryMessage__storage_, apnToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gcmToken",
        .dataTypeSpecific.className = GPBStringifySymbol(PushNotificationRegistryMessage_GcmToken),
        .number = PushNotificationRegistryMessage_FieldNumber_GcmToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushNotificationRegistryMessage__storage_, gcmToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushNotificationRegistryMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushNotificationRegistryMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushNotificationRegistryMessage_ApnToken

@implementation PushNotificationRegistryMessage_ApnToken

@dynamic registrationId;
@dynamic bundleIdentifier;
@dynamic payloadByteSize;

typedef struct PushNotificationRegistryMessage_ApnToken__storage_ {
  uint32_t _has_storage_[1];
  int32_t payloadByteSize;
  NSString *registrationId;
  NSString *bundleIdentifier;
} PushNotificationRegistryMessage_ApnToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "registrationId",
        .dataTypeSpecific.className = NULL,
        .number = PushNotificationRegistryMessage_ApnToken_FieldNumber_RegistrationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushNotificationRegistryMessage_ApnToken__storage_, registrationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = PushNotificationRegistryMessage_ApnToken_FieldNumber_BundleIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushNotificationRegistryMessage_ApnToken__storage_, bundleIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payloadByteSize",
        .dataTypeSpecific.className = NULL,
        .number = PushNotificationRegistryMessage_ApnToken_FieldNumber_PayloadByteSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushNotificationRegistryMessage_ApnToken__storage_, payloadByteSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushNotificationRegistryMessage_ApnToken class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushNotificationRegistryMessage_ApnToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PushNotificationRegistryMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushNotificationRegistryMessage_GcmToken

@implementation PushNotificationRegistryMessage_GcmToken

@dynamic registrationId;

typedef struct PushNotificationRegistryMessage_GcmToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *registrationId;
} PushNotificationRegistryMessage_GcmToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "registrationId",
        .dataTypeSpecific.className = NULL,
        .number = PushNotificationRegistryMessage_GcmToken_FieldNumber_RegistrationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushNotificationRegistryMessage_GcmToken__storage_, registrationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushNotificationRegistryMessage_GcmToken class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushNotificationRegistryMessage_GcmToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PushNotificationRegistryMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RecycleInventoryItemMessage

@implementation RecycleInventoryItemMessage

@dynamic itemId;
@dynamic count;

typedef struct RecycleInventoryItemMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  int32_t count;
} RecycleInventoryItemMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = RecycleInventoryItemMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecycleInventoryItemMessage__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = RecycleInventoryItemMessage_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RecycleInventoryItemMessage__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecycleInventoryItemMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecycleInventoryItemMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RecycleInventoryItemMessage_ItemId_RawValue(RecycleInventoryItemMessage *message) {
  GPBDescriptor *descriptor = [RecycleInventoryItemMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RecycleInventoryItemMessage_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetRecycleInventoryItemMessage_ItemId_RawValue(RecycleInventoryItemMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [RecycleInventoryItemMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RecycleInventoryItemMessage_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RegisterBackgroundDeviceMessage

@implementation RegisterBackgroundDeviceMessage

@dynamic deviceType;
@dynamic deviceId;

typedef struct RegisterBackgroundDeviceMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceType;
  NSString *deviceId;
} RegisterBackgroundDeviceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = RegisterBackgroundDeviceMessage_FieldNumber_DeviceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterBackgroundDeviceMessage__storage_, deviceType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = RegisterBackgroundDeviceMessage_FieldNumber_DeviceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterBackgroundDeviceMessage__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterBackgroundDeviceMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterBackgroundDeviceMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReleasePokemonMessage

@implementation ReleasePokemonMessage

@dynamic pokemonId;
@dynamic pokemonIdsArray, pokemonIdsArray_Count;

typedef struct ReleasePokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *pokemonIdsArray;
  uint64_t pokemonId;
} ReleasePokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = ReleasePokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReleasePokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "pokemonIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ReleasePokemonMessage_FieldNumber_PokemonIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ReleasePokemonMessage__storage_, pokemonIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReleasePokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReleasePokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetAvatarItemAsViewedMessage

@implementation SetAvatarItemAsViewedMessage

@dynamic avatarTemplateIdArray, avatarTemplateIdArray_Count;

typedef struct SetAvatarItemAsViewedMessage__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *avatarTemplateIdArray;
} SetAvatarItemAsViewedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatarTemplateIdArray",
        .dataTypeSpecific.className = NULL,
        .number = SetAvatarItemAsViewedMessage_FieldNumber_AvatarTemplateIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SetAvatarItemAsViewedMessage__storage_, avatarTemplateIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAvatarItemAsViewedMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAvatarItemAsViewedMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetAvatarMessage

@implementation SetAvatarMessage

@dynamic hasPlayerAvatar, playerAvatar;

typedef struct SetAvatarMessage__storage_ {
  uint32_t _has_storage_[1];
  PlayerAvatar *playerAvatar;
} SetAvatarMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerAvatar",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayerAvatar),
        .number = SetAvatarMessage_FieldNumber_PlayerAvatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetAvatarMessage__storage_, playerAvatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAvatarMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAvatarMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetBuddyPokemonMessage

@implementation SetBuddyPokemonMessage

@dynamic pokemonId;

typedef struct SetBuddyPokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  uint64_t pokemonId;
} SetBuddyPokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = SetBuddyPokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetBuddyPokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetBuddyPokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetBuddyPokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetContactSettingsMessage

@implementation SetContactSettingsMessage

@dynamic hasContactSettings, contactSettings;

typedef struct SetContactSettingsMessage__storage_ {
  uint32_t _has_storage_[1];
  ContactSettings *contactSettings;
} SetContactSettingsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contactSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(ContactSettings),
        .number = SetContactSettingsMessage_FieldNumber_ContactSettings,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetContactSettingsMessage__storage_, contactSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetContactSettingsMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetContactSettingsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetFavoritePokemonMessage

@implementation SetFavoritePokemonMessage

@dynamic pokemonId;
@dynamic isFavorite;

typedef struct SetFavoritePokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  int64_t pokemonId;
} SetFavoritePokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = SetFavoritePokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetFavoritePokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isFavorite",
        .dataTypeSpecific.className = NULL,
        .number = SetFavoritePokemonMessage_FieldNumber_IsFavorite,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetFavoritePokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetFavoritePokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetPlayerTeamMessage

@implementation SetPlayerTeamMessage

@dynamic team;

typedef struct SetPlayerTeamMessage__storage_ {
  uint32_t _has_storage_[1];
  TeamColor team;
} SetPlayerTeamMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "team",
        .dataTypeSpecific.enumDescFunc = TeamColor_EnumDescriptor,
        .number = SetPlayerTeamMessage_FieldNumber_Team,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetPlayerTeamMessage__storage_, team),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetPlayerTeamMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetPlayerTeamMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SetPlayerTeamMessage_Team_RawValue(SetPlayerTeamMessage *message) {
  GPBDescriptor *descriptor = [SetPlayerTeamMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetPlayerTeamMessage_FieldNumber_Team];
  return GPBGetMessageInt32Field(message, field);
}

void SetSetPlayerTeamMessage_Team_RawValue(SetPlayerTeamMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [SetPlayerTeamMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetPlayerTeamMessage_FieldNumber_Team];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SfidaActionLogMessage

@implementation SfidaActionLogMessage


typedef struct SfidaActionLogMessage__storage_ {
  uint32_t _has_storage_[1];
} SfidaActionLogMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SfidaActionLogMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(SfidaActionLogMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SfidaRegistrationMessage

@implementation SfidaRegistrationMessage

@dynamic sfidaId;

typedef struct SfidaRegistrationMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sfidaId;
} SfidaRegistrationMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sfidaId",
        .dataTypeSpecific.className = NULL,
        .number = SfidaRegistrationMessage_FieldNumber_SfidaId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SfidaRegistrationMessage__storage_, sfidaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SfidaRegistrationMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SfidaRegistrationMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StartGymBattleMessage

@implementation StartGymBattleMessage

@dynamic gymId;
@dynamic attackingPokemonIdsArray, attackingPokemonIdsArray_Count;
@dynamic defendingPokemonId;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct StartGymBattleMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *gymId;
  GPBUInt64Array *attackingPokemonIdsArray;
  uint64_t defendingPokemonId;
  double playerLatitude;
  double playerLongitude;
} StartGymBattleMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = StartGymBattleMessage_FieldNumber_GymId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StartGymBattleMessage__storage_, gymId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attackingPokemonIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = StartGymBattleMessage_FieldNumber_AttackingPokemonIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StartGymBattleMessage__storage_, attackingPokemonIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "defendingPokemonId",
        .dataTypeSpecific.className = NULL,
        .number = StartGymBattleMessage_FieldNumber_DefendingPokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StartGymBattleMessage__storage_, defendingPokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = StartGymBattleMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StartGymBattleMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = StartGymBattleMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StartGymBattleMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StartGymBattleMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StartGymBattleMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateNotificationMessage

@implementation UpdateNotificationMessage

@dynamic notificationIdsArray, notificationIdsArray_Count;
@dynamic createTimestampMsArray, createTimestampMsArray_Count;
@dynamic state;

typedef struct UpdateNotificationMessage__storage_ {
  uint32_t _has_storage_[1];
  NotificationState state;
  NSMutableArray *notificationIdsArray;
  GPBInt64Array *createTimestampMsArray;
} UpdateNotificationMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = UpdateNotificationMessage_FieldNumber_NotificationIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateNotificationMessage__storage_, notificationIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTimestampMsArray",
        .dataTypeSpecific.className = NULL,
        .number = UpdateNotificationMessage_FieldNumber_CreateTimestampMsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateNotificationMessage__storage_, createTimestampMsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = NotificationState_EnumDescriptor,
        .number = UpdateNotificationMessage_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateNotificationMessage__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateNotificationMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateNotificationMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UpdateNotificationMessage_State_RawValue(UpdateNotificationMessage *message) {
  GPBDescriptor *descriptor = [UpdateNotificationMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdateNotificationMessage_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetUpdateNotificationMessage_State_RawValue(UpdateNotificationMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UpdateNotificationMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdateNotificationMessage_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UpgradePokemonMessage

@implementation UpgradePokemonMessage

@dynamic pokemonId;

typedef struct UpgradePokemonMessage__storage_ {
  uint32_t _has_storage_[1];
  uint64_t pokemonId;
} UpgradePokemonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = UpgradePokemonMessage_FieldNumber_PokemonId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpgradePokemonMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpgradePokemonMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpgradePokemonMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UseIncenseMessage

@implementation UseIncenseMessage

@dynamic incenseType;

typedef struct UseIncenseMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId incenseType;
} UseIncenseMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "incenseType",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseIncenseMessage_FieldNumber_IncenseType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseIncenseMessage__storage_, incenseType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseIncenseMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseIncenseMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseIncenseMessage_IncenseType_RawValue(UseIncenseMessage *message) {
  GPBDescriptor *descriptor = [UseIncenseMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseIncenseMessage_FieldNumber_IncenseType];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseIncenseMessage_IncenseType_RawValue(UseIncenseMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseIncenseMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseIncenseMessage_FieldNumber_IncenseType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UseItemCaptureMessage

@implementation UseItemCaptureMessage

@dynamic itemId;
@dynamic encounterId;
@dynamic spawnPointId;

typedef struct UseItemCaptureMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  NSString *spawnPointId;
  uint64_t encounterId;
} UseItemCaptureMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemCaptureMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemCaptureMessage__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "encounterId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureMessage_FieldNumber_EncounterId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemCaptureMessage__storage_, encounterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "spawnPointId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemCaptureMessage_FieldNumber_SpawnPointId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UseItemCaptureMessage__storage_, spawnPointId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemCaptureMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemCaptureMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemCaptureMessage_ItemId_RawValue(UseItemCaptureMessage *message) {
  GPBDescriptor *descriptor = [UseItemCaptureMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemCaptureMessage_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemCaptureMessage_ItemId_RawValue(UseItemCaptureMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemCaptureMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemCaptureMessage_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UseItemEggIncubatorMessage

@implementation UseItemEggIncubatorMessage

@dynamic itemId;
@dynamic pokemonId;

typedef struct UseItemEggIncubatorMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *itemId;
  uint64_t pokemonId;
} UseItemEggIncubatorMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemEggIncubatorMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemEggIncubatorMessage__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemEggIncubatorMessage_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemEggIncubatorMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemEggIncubatorMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemEggIncubatorMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UseItemEncounterMessage

@implementation UseItemEncounterMessage

@dynamic item;
@dynamic encounterId;
@dynamic spawnPointGuid;

typedef struct UseItemEncounterMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId item;
  NSString *spawnPointGuid;
  uint64_t encounterId;
} UseItemEncounterMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "item",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemEncounterMessage_FieldNumber_Item,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemEncounterMessage__storage_, item),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "encounterId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemEncounterMessage_FieldNumber_EncounterId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemEncounterMessage__storage_, encounterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "spawnPointGuid",
        .dataTypeSpecific.className = NULL,
        .number = UseItemEncounterMessage_FieldNumber_SpawnPointGuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UseItemEncounterMessage__storage_, spawnPointGuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemEncounterMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemEncounterMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemEncounterMessage_Item_RawValue(UseItemEncounterMessage *message) {
  GPBDescriptor *descriptor = [UseItemEncounterMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemEncounterMessage_FieldNumber_Item];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemEncounterMessage_Item_RawValue(UseItemEncounterMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemEncounterMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemEncounterMessage_FieldNumber_Item];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UseItemGymMessage

@implementation UseItemGymMessage

@dynamic itemId;
@dynamic gymId;
@dynamic playerLatitude;
@dynamic playerLongitude;

typedef struct UseItemGymMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  NSString *gymId;
  double playerLatitude;
  double playerLongitude;
} UseItemGymMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemGymMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemGymMessage__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemGymMessage_FieldNumber_GymId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemGymMessage__storage_, gymId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerLatitude",
        .dataTypeSpecific.className = NULL,
        .number = UseItemGymMessage_FieldNumber_PlayerLatitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UseItemGymMessage__storage_, playerLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playerLongitude",
        .dataTypeSpecific.className = NULL,
        .number = UseItemGymMessage_FieldNumber_PlayerLongitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UseItemGymMessage__storage_, playerLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemGymMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemGymMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemGymMessage_ItemId_RawValue(UseItemGymMessage *message) {
  GPBDescriptor *descriptor = [UseItemGymMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemGymMessage_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemGymMessage_ItemId_RawValue(UseItemGymMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemGymMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemGymMessage_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UseItemMoveRerollMessage

@implementation UseItemMoveRerollMessage

@dynamic itemId;
@dynamic pokemonId;

typedef struct UseItemMoveRerollMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  uint64_t pokemonId;
} UseItemMoveRerollMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemMoveRerollMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemMoveRerollMessage__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemMoveRerollMessage_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemMoveRerollMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemMoveRerollMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemMoveRerollMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemMoveRerollMessage_ItemId_RawValue(UseItemMoveRerollMessage *message) {
  GPBDescriptor *descriptor = [UseItemMoveRerollMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemMoveRerollMessage_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemMoveRerollMessage_ItemId_RawValue(UseItemMoveRerollMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemMoveRerollMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemMoveRerollMessage_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UseItemPotionMessage

@implementation UseItemPotionMessage

@dynamic itemId;
@dynamic pokemonId;

typedef struct UseItemPotionMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  uint64_t pokemonId;
} UseItemPotionMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemPotionMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemPotionMessage__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemPotionMessage_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemPotionMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemPotionMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemPotionMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemPotionMessage_ItemId_RawValue(UseItemPotionMessage *message) {
  GPBDescriptor *descriptor = [UseItemPotionMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemPotionMessage_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemPotionMessage_ItemId_RawValue(UseItemPotionMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemPotionMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemPotionMessage_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UseItemRareCandyMessage

@implementation UseItemRareCandyMessage

@dynamic itemId;
@dynamic pokemonId;

typedef struct UseItemRareCandyMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  PokemonId pokemonId;
} UseItemRareCandyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemRareCandyMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemRareCandyMessage__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.enumDescFunc = PokemonId_EnumDescriptor,
        .number = UseItemRareCandyMessage_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemRareCandyMessage__storage_, pokemonId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemRareCandyMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemRareCandyMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemRareCandyMessage_ItemId_RawValue(UseItemRareCandyMessage *message) {
  GPBDescriptor *descriptor = [UseItemRareCandyMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemRareCandyMessage_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemRareCandyMessage_ItemId_RawValue(UseItemRareCandyMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemRareCandyMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemRareCandyMessage_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t UseItemRareCandyMessage_PokemonId_RawValue(UseItemRareCandyMessage *message) {
  GPBDescriptor *descriptor = [UseItemRareCandyMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemRareCandyMessage_FieldNumber_PokemonId];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemRareCandyMessage_PokemonId_RawValue(UseItemRareCandyMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemRareCandyMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemRareCandyMessage_FieldNumber_PokemonId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UseItemReviveMessage

@implementation UseItemReviveMessage

@dynamic itemId;
@dynamic pokemonId;

typedef struct UseItemReviveMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
  uint64_t pokemonId;
} UseItemReviveMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemReviveMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemReviveMessage__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pokemonId",
        .dataTypeSpecific.className = NULL,
        .number = UseItemReviveMessage_FieldNumber_PokemonId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UseItemReviveMessage__storage_, pokemonId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemReviveMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemReviveMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemReviveMessage_ItemId_RawValue(UseItemReviveMessage *message) {
  GPBDescriptor *descriptor = [UseItemReviveMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemReviveMessage_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemReviveMessage_ItemId_RawValue(UseItemReviveMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemReviveMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemReviveMessage_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UseItemXpBoostMessage

@implementation UseItemXpBoostMessage

@dynamic itemId;

typedef struct UseItemXpBoostMessage__storage_ {
  uint32_t _has_storage_[1];
  ItemId itemId;
} UseItemXpBoostMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.enumDescFunc = ItemId_EnumDescriptor,
        .number = UseItemXpBoostMessage_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UseItemXpBoostMessage__storage_, itemId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UseItemXpBoostMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UseItemXpBoostMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UseItemXpBoostMessage_ItemId_RawValue(UseItemXpBoostMessage *message) {
  GPBDescriptor *descriptor = [UseItemXpBoostMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemXpBoostMessage_FieldNumber_ItemId];
  return GPBGetMessageInt32Field(message, field);
}

void SetUseItemXpBoostMessage_ItemId_RawValue(UseItemXpBoostMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UseItemXpBoostMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UseItemXpBoostMessage_FieldNumber_ItemId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - VerifyChallengeMessage

@implementation VerifyChallengeMessage

@dynamic token;

typedef struct VerifyChallengeMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} VerifyChallengeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = VerifyChallengeMessage_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyChallengeMessage__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyChallengeMessage class]
                                     rootClass:[PogoprotosNetworkingRequestsMessagesRoot class]
                                          file:PogoprotosNetworkingRequestsMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyChallengeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
